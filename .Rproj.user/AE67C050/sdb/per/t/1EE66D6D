{
    "contents" : "#----------------------------------#\n# Functions for plotting data from #\n# simple choice and response time  #\n# tasks                            #\n#----------------------------------#\n\n# Index\n# Lookup - 01:  cdf_curve\n# Lookup - 02:  pdf_curve\n# Lookup - 03:  hazard_curve\n# Lookup - 04:  quantile_points\n# Lookup - 05:  CAF_points\n# Lookup - 06:  blankRTplot\n\n### TO DO ###\n# Add references\n# Add examples (hazard function)\n# Add aggregation over group factor (hazard function)\n# Add accuracy-latency plots\n# Add helper functions for plotting variability (e.g. SEs)\n\n# Useful functions for package creation\n# library(devtools)\n# library(roxygen2)\n\n# Lookup - 01\n#' Joint CDF curves for response time and choice data.\n#'\n#' Draws a line for the estimated joint CDF of a set response\n#' times and choices on an already existing plot.\n#'\n#' @param rt vector of response times.\n#' @param ch a vector of binary choices (i.e. 0 or 1).\n#' @param sel If 0, the CDF for responses times when choice = 0 is\n#'   drawn. If 1, the CDF for responses times when choice = 1 is drawn.\n#' @param grp an optional vector with a grouping factor (e.g. subjects).\n#' @param plt a named list that allows specification of graphical\n#'   parameters. The named list plt$ln can be used to set the graphical\n#'   elements (e.g.. the options \\code{lwd} and \\code{lty}) for the\n#'   drawn line. The named lists plt$pt1 and plt$pt2 can be used to\n#'   set the graphical elements (e.g. the option \\code{pch}) for the\n#'   points denoting the median and mean.\n#' @param opt logical vector; indicates if 1) the joint distribution\n#'   should be used, 2) the line should be drawn, and 3) if output\n#'   should be returned.\n#' @return A list consisting of...\n#' \\describe{\n#'   \\item{\\code{CDF}}{a matrix with the estimated cumulative\n#'     probabilities and the corresonding resopnse times.}\n#'   \\item{\\code{Median}}{the response time and cumulative\n#'     probability for the median}\n#'   \\item{\\code{Mean}}{the response time and cumulative\n#'     probability for the mean}\n#'   }\n#' @examples\n#' # Load in example dataset\n#' data(\"priming_data\")\n#' d = priming_data\n#' layout( cbind(1,2) )\n#' # Single subject\n#' sel = d$Condition == 4 & d$Subject == 1\n#' rt = d$RT[sel]; ch = d$Accuracy[sel]\n#' blankRTplot()\n#' cdf_curve( rt, ch )\n#' plt = list( ln = list( lty = 2 ) )\n#' cdf_curve( rt, ch, sel = 0, plt = plt )\n#' # Aggregating over multiple subjects\n#' sel = d$Condition == 4\n#' rt = d$RT[sel]; ch = d$Choice[sel]; grp = d$Subject[sel]\n#' blankRTplot( bty = 'l', ver = 'CDF', cex.axis = 1.5, cex.lab = 1.5 )\n#' plt = list( ln = list( lwd = 2 ), pt1 = list( bg = 'grey' ) )\n#' cdf_curve( rt, ch, grp = grp, plt = plt )\n#' plt = list( ln = list( lty = 2, lwd = 2 ), pt1 = list( bg = 'grey' ) )\n#' cdf_curve( rt, ch, sel = 0, grp = grp, plt = plt )\n#' @export\n\ncdf_curve = function( rt, ch, sel = 1, grp = NULL, plt = NULL,\n                      opt = c(T,T,F) ) {\n\n  # Set options for joint distribution, drawing, and output\n  jnt = opt[1];\n  draw = opt[2];\n  out = opt[3];\n\n  # Determine line and point characteristics\n  tmp = curve_defaults( plt )\n  lnDefaults = tmp[[1]]\n  medDefaults = tmp[[2]]\n  avgDefaults = tmp[[3]]\n\n  # If there is no grouping variable\n  if ( length( grp ) == 0 ) {\n\n    # Empirical estimate of CDF for response times\n    n = sum( ch == sel )\n    p = (1:n)/n\n    x = sort( rt[ ch == sel ] )\n\n    # Determine median\n    medVal = max( which( p <= .5 ) )\n    xMed = x[ medVal ];\n\n    # Determine mean\n    xAvg = mean( x )\n    intrvl = c( max( which( x <= xAvg ) ), min( which( x > xAvg ) ) )\n\n    # Adjust asymptote if estimating joint CDF\n    if (jnt) p = p*(n/length(ch));\n\n    # Determine y-axis values\n    pMed = p[ medVal ];\n    pAvg = lnInterp( xAvg, p[intrvl], x[intrvl] )\n  }\n  # If there is a grouping variable\n  if ( length( grp ) == length( rt ) ) {\n\n    xAll = rt[ ch == sel ]\n    g = grp[ ch == sel ]\n\n    # Adjust estimate of curve based on sample size\n    n = aggregate( xAll, list( g ), length )$x\n    if ( min(n) < 20 ) prb = (1:round( mean( n ) ))/round( mean( n ) )\n    if ( min(n) >= 20 & min(n) < 100 ) prb = seq( 0, 1, .05 )\n    if ( min(n) >= 100 & min(n) < 200 ) prb = seq( 0, 1, .02 )\n    if ( min(n) >= 200 ) prb = seq( 0, 1, .01 )\n\n    allQ = aggregate( xAll, list( g ), quantile,\n                   prob = prb )\n    colnames( allQ ) = c('G','Q')\n\n    adj = aggregate( ch, list( grp ), function(x) mean(x == sel) )\n    p = matrix( prb, nrow(allQ), length(prb), byrow = T )\n    if (jnt) p = p*adj$x;\n\n    if ( length( dim(allQ$Q) ) > 0 ) x = colMeans( allQ$Q ) else\n      x = mean( allQ$Q )\n    p = colMeans( p )\n\n    xAvg = mean( aggregate( xAll, list( g ), mean )$x )\n    intrvl = c( max( which( x <= xAvg ) ), min( which( x > xAvg ) ) )\n    pAvg = lnInterp( xAvg, p[intrvl], x[intrvl] )\n\n    xMed = mean( aggregate( xAll, list( g ), median )$x )\n    intrvl = c( max( which( x <= xMed ) ), min( which( x > xMed ) ) )\n    pMed = lnInterp( xMed, p[intrvl], x[intrvl] )\n\n  }\n\n  if (draw) {\n    lines( x, p, lty = lnDefaults$lty, lwd = lnDefaults$lwd,\n           col = lnDefaults$col, type = lnDefaults$type )\n    points( xMed, pMed, pch = medDefaults$pch,\n            bg = medDefaults$bg, lwd = medDefaults$lwd,\n            col = medDefaults$col, cex = medDefaults$cex,\n            type = medDefaults$type )\n    points( xAvg, pAvg, pch = avgDefaults$pch,\n            bg = avgDefaults$bg, lwd = avgDefaults$lwd,\n            col = avgDefaults$col, cex = avgDefaults$cex,\n            type = avgDefaults$type )\n  }\n\n  if (out) return( list( CDF = cbind(x,p), Median = c( xMed, pMed ),\n                         Mean = c( xAvg, pAvg ) ) )\n}\n\n# Lookup - 02\n#' Joint PDF curves for response time and choice data.\n#'\n#' Draws a line for the estimated joint PDF of a set response\n#' times and choices on an already existing plot.\n#'\n#' @param rt vector of response times.\n#' @param ch a vector of binary choices (i.e. 0 or 1).\n#' @param sel If 0, the PDF for responses times when choice = 0 is\n#'   drawn. If 1, the PDF for responses times when choice = 1 is drawn.\n#' @param grp an optional vector with a grouping factor (e.g. subjects).\n#' @param plt a named list that allows specification of graphical\n#'   parameters. The named list plt$ln can be used to set the graphical\n#'   elements (e.g.. the options \\code{lwd} and \\code{lty}) for the\n#'   drawn line. The named lists plt$pt1 and plt$pt2 can be used to\n#'   set the graphical elements (e.g. the option \\code{pch}) for the\n#'   points denoting the median and mean.\n#' @param opt logical vector; indicates if 1) the joint distribution\n#'   should be used, 2) the line should be drawn, and 3) if output\n#'   should be returned.\n#' @return A list consisting of...\n#' \\describe{\n#'   \\item{\\code{PDF}}{a matrix with the estimated density}\n#'   \\item{\\code{Mode}}{the response time and likelihood for the mode}\n#'   \\item{\\code{Mean}}{the response time and likelihood for the mean}\n#'   }\n#' @examples\n#' # Load in example data\n#' data(priming_data)\n#' d = priming_data\n#' layout( cbind(1,2) )\n#' # Single subject\n#' sel = d$Condition == 5 & d$Subject == 16\n#' rt = d$RT[sel]; ch = d$Accuracy[sel]\n#' blankRTplot(yDim=c(0,3),ver='PDF')\n#' pdf_curve( rt, ch )\n#' plt = list( ln = list( col = 'blue' ) )\n#' pdf_curve( rt, ch, sel = 0, plt = plt )\n#' # Aggregating over multiple subjects\n#' sel = d$Condition == 5\n#' rt = d$RT[sel]; ch = d$Choice[sel]; grp = d$Subject[sel]\n#' blankRTplot( yDim = c(0,2), bty = 'l', ver = 'CDF', cex.axis = 1.5,\n#'   cex.lab = 1.5 )\n#' plt = list( ln = list( lwd = 2 ), pt1 = list( bg = 'grey', cex = 1.5 ),\n#'   pt2 = list( type = 'n' ) )\n#' pdf_curve( rt, ch, grp = grp, plt = plt )\n#' plt = list( ln = list( lty = 2, lwd = 2 ),\n#'   pt1 = list( pch = 15, cex = 1.5 ),\n#'   pt2 = list( type = 'n' ) )\n#' pdf_curve( rt, ch, sel = 0, grp = grp, plt = plt )\n#' @export\n\npdf_curve = function( rt, ch, sel = 1, grp = NULL, plt = NULL,\n                      opt = c(T,T,F) ) {\n\n  # Set options for joint distribution, drawing, and output\n  jnt = opt[1];\n  draw = opt[2];\n  out = opt[3];\n\n  # Determine line and point characteristics\n  tmp = curve_defaults( plt )\n  lnDefaults = tmp[[1]]\n  modeDefaults = tmp[[2]]\n  avgDefaults = tmp[[3]]\n\n  # If there is no grouping variable\n  if ( length( grp ) == 0 ) {\n\n    # Estimate density using base R\n    xa = rt[ ch == sel ]\n    dn = density( xa )\n    x = dn$x; d = dn$y\n\n    if (jnt) d = d*mean( ch == sel )\n\n    # Determine mode\n    modeVal = which( d == max( d ) )\n    xMode = x[ modeVal ];\n    dMode = d[ modeVal ];\n\n    # Determine mean\n    xAvg = mean( xa )\n    avgVal = max( which( x <= xAvg ) )\n    xAvg = x[ avgVal ];\n    dAvg = d[ avgVal ];\n\n  }\n  # If there is a grouping variable\n  if ( length( grp ) == length( rt ) ) {\n\n    cur_t = rt[ ch == sel ]\n    cur_grp = grp[ ch == sel ]\n\n    x = seq( min(cur_t), quantile( cur_t, .99), length = 100 )\n    all_grp = sort( unique( cur_grp ) )\n    all_dn = matrix( 0, length( all_grp ), 100 )\n\n    for (g in 1:length(all_grp) ) {\n      dn = density( cur_t[ cur_grp == all_grp[g] ] )\n      # Extract density estimates for\n      df = approxfun(dn) # Approximates density function\n\n      all_dn[g,] = df(x);\n\n    }\n    all_dn[is.na( all_dn )] = 0\n\n    adj = aggregate( ch, list( grp ), function(x) mean(x == sel) )\n    if (jnt) all_dn = all_dn*adj$x;\n\n    # Aggregate over subjects\n    d = colMeans( all_dn )\n\n    # Determine mode\n    modeVal = which( d == max( d ) )\n    xMode = x[ modeVal ];\n    dMode = d[ modeVal ];\n\n    # Determine mean\n    xAvg = mean( cur_t )\n    avgVal = max( which( x <= xAvg ) )\n    xAvg = x[ avgVal ];\n    dAvg = d[ avgVal ];\n\n    dn = all_dn\n\n  }\n\n  if (draw) {\n    lines( x, d, lty = lnDefaults$lty, lwd = lnDefaults$lwd,\n           col = lnDefaults$col, type = lnDefaults$type )\n    points( xMode, dMode, pch = modeDefaults$pch,\n            bg = modeDefaults$bg, lwd = modeDefaults$lwd,\n            col = modeDefaults$col, cex = modeDefaults$cex,\n            type = modeDefaults$type )\n    points( xAvg, dAvg, pch = avgDefaults$pch,\n            bg = avgDefaults$bg, lwd = avgDefaults$lwd,\n            col = avgDefaults$col, cex = avgDefaults$cex,\n            type = avgDefaults$type )\n  }\n\n  if (out) return( list(\n    PDF = dn, Mode = c( xMode, dMode ), Mean = c( xAvg, dAvg ) ) )\n}\n\n# Lookup - 03\n#' Estimated hazard function for response time and choice data.\n#'\n#' Draws a line for the estimated joint PDF of a set response\n#' times and choices on an already existing plot.\n#'\n#' @param rt vector of response times.\n#' @param ch a vector of binary choices (i.e. 0 or 1).\n#' @param sel If 0, the PDF for responses times when choice = 0 is\n#'   drawn. If 1, the PDF for responses times when choice = 1 is drawn.\n#' @param opt logical vector; indicates if 1) the joint distribution\n#'   should be used, 2) the line should be drawn, and 3) if output\n#'   should be returned.\n#' @param ...  additional plotting parameters.\n#' @return A matrix giving the selected response times, density\n#'   estimates, cumulative probabilities, and the estimated hazard\n#'   function.\n#' @export\n\nhazard_curve = function(rt, ch, sel = 1, opt = c(T,T,F), ...) {\n\n  # Set options for joint distribution, drawing, and output\n  jnt = opt[1];\n  draw = opt[2];\n  out = opt[3];\n\n  # Extract relevant response times\n  x = rt[ ch == sel ]\n\n  adj = mean( ch == sel )\n\n  # Estimate PDF\n  dn = density(x)\n  # Extract density estimates for observed response times\n  df = approxfun(dn) # Approximates density function\n  g = df( sort(x) )\n\n  # Estimate distribution function values\n  G = (1:length(x))/length(x)\n\n  # Adjust values for joint distribution\n  if (jnt) { g = g*adj; G = G*adj }\n\n  h = g/(1-G) # Calculate empirical hazard function\n\n  if (draw) {\n\n    lines( sort(x), h, ... )\n\n  }\n\n  if (out) return( as.data.frame( cbind( rt = sort(x),\n                                         g = g, G = G, h = h ) ) )\n}\n\n# Lookup - 04\n#' Quantile-probability estimates\n#'\n#' Draws the estimated quantiles based on the corresponding joint\n#' cumulative probabilities for a set of response times and choices.\n#'\n#' @param rt vector of response times.\n#' @param ch a vector of binary choices (i.e. 0 or 1).\n#' @param sel If 0, the quantile-probability estimates for responses\n#'   times when choice = 0 are drawn. If 1, the quantile-probability\n#'   estimates for responses times when choice = 1 are drawn.\n#' @param prb the sequence of cumulative probabilities for which the\n#'   quantiles should be determined.\n#' @param plt a named list that allows specification of graphical\n#'   parameters. The named list plt$ln can be used to set the graphical\n#'   elements (e.g.. the options \\code{lwd} and \\code{lty}) for the\n#'   drawn line. The named list plt$pt can be used to\n#'   set the graphical elements (e.g. the option \\code{pch}) for the\n#'   drawn points.\n#' @param opt logical vector; indicates if 1) the joint distribution\n#'   should be used, 2) the line should be drawn, and 3) if output\n#'   should be returned.\n#' @return A matrix giving the quantile estimates and the corresponding\n#'   cumulative probabilities.\n#' @examples\n#' # Load in example dataset\n#' data(\"priming_data\")\n#' d = priming_data\n#' layout( cbind(1,2) )\n#' # Single subject\n#' sel = d$Condition == 6 & d$Subject == 20\n#' rt = d$RT[sel]; ch = d$Accuracy[sel]\n#' blankRTplot(xDim = c(0,1), ver='QPE')\n#' quantile_points( rt, ch )\n#' plt = list( ln = list( type = 'n' ), pt = list( pch = 18,\n#'   col = 'red' ) )\n#' quantile_points( rt, ch, sel = 0, plt = plt )\n#' # Aggregating over multiple subjects\n#' sel = d$Condition == 6\n#' rt = d$RT[sel]; ch = d$Choice[sel]; grp = d$Subject[sel]\n#' blankRTplot( xDim = c(0,1), bty = 'l', ver = 'QPE', cex.axis = 1.5,\n#'   cex.lab = 1.5 )\n#' plt = list( ln = list( type = 'n' ),\n#'   pt = list( bg = 'grey', pch = 21, cex = 1.5 ) )\n#' quantile_points( rt, ch, sel = 1, plt = plt )\n#' plt = list( ln = list( type = 'n' ),\n#'   pt = list( bg = 'white', pch = 22, cex = 1.5 ) )\n#' quantile_points( rt, ch, sel = 0, plt = plt )\n#' @export\n\nquantile_points = function( rt, ch, sel = 1, prb = seq( .1, .9, .2 ),\n                            grp = NULL, plt = NULL, opt = c(T,T,F) ) {\n\n  # Set options for joint distribution, drawing, and output\n  jnt = opt[1];\n  draw = opt[2];\n  out = opt[3];\n\n  # Determine line and point characteristics\n  tmp = point_defaults( plt )\n  lnDefaults = tmp[[1]]\n  ptDefaults = tmp[[2]]\n\n  # If there is no grouping variable\n  if ( length( grp ) == 0 ) {\n\n    x = rt[ ch == sel ]\n    adj = mean( ch == sel )\n\n    q = quantile( x, prob = prb )\n    if (jnt) y = prb*adj else y = prb\n\n  }\n  # If there is a grouping variable\n  if ( length( grp ) == length( rt ) ) {\n\n    xAll = rt[ ch == sel ]\n    grpAll = grp[ ch == sel ]\n\n    allQ = aggregate( xAll, list( grpAll ), quantile, prob = prb )\n    colnames( allQ ) = c('G','Q')\n\n    adj = aggregate( ch, list( grp ), function(x) mean(x == sel) )\n    y = matrix( prb, nrow(allQ), length(prb), byrow = T )\n    if (jnt) y = y*adj$x;\n\n    q = colMeans( allQ )\n    y = colMeans( y )\n\n  }\n\n  if (draw) {\n    lines( q, y, lty = lnDefaults$lty, lwd = lnDefaults$lwd,\n           col = lnDefaults$col, type = lnDefaults$type )\n    points( q, y, pch = ptDefaults$pch,\n            bg = ptDefaults$bg, lwd = ptDefaults$lwd,\n            col = ptDefaults$col, cex = ptDefaults$cex,\n            type = ptDefaults$type )\n  }\n\n  if (out) return( cbind( q = q, p = y ) )\n}\n\n# Lookup - 05\n#' Conditional accuracy function\n#'\n#' Draws the conditional accuracy at different response time quantiles.\n#'\n#' @param rt vector of response times.\n#' @param ch a vector of binary choices (i.e. 0 or 1).\n#' @param prb the sequence of cumulative probabilities for which the\n#'   quantiles should be determined.\n#' @param plt a named list that allows specification of graphical\n#'   parameters. The named list plt$ln can be used to set the graphical\n#'   elements (e.g.. the options \\code{lwd} and \\code{lty}) for the\n#'   drawn line. The named list plt$pt can be used to\n#'   set the graphical elements (e.g. the option \\code{pch}) for the\n#'   drawn points.\n#' @param opt logical vector; indicates if 1) the line should be drawn,\n#'   and 2) if output should be returned.\n#' @return A matrix giving the quantile estimates and the corresponding\n#'   cumulative probabilities.\n#' @examples\n#' # Load in example dataset\n#' data(\"priming_data\")\n#' d = priming_data\n#' layout( cbind(1,2) )\n#' # Single subject\n#' sel = d$Condition == 2 & d$Subject == 6\n#' rt = d$RT[sel]; ch = d$Accuracy[sel]\n#' blankRTplot( xDim = c(.2,1), yDim=c(.5,1), ver='CAF')\n#' plt = list( pt = list( pch = 19 ) )\n#' CAF_points( rt, ch, plt = plt )\n#' # Aggregating over multiple subjects\n#' sel = d$Condition == 2\n#' rt = d$RT[sel]; ch = d$Accuracy[sel]; grp = d$Subject[sel]\n#' blankRTplot( xDim = c(.2,1), yDim = c(.5,1),\n#'   bty = 'l', ver = 'QPE', cex.axis = 1.5,\n#'   cex.lab = 1.5 )\n#' plt = list( pt = list( bg = 'grey', pch = 23, cex = 1.2 ) )\n#' CAF_points( rt, ch, grp = grp, plt = plt )\n#' @export\n\nCAF_points = function( rt, ch, prb = seq( .1, .9, .2 ),\n                            grp = NULL, plt = NULL, opt = c(T,F) ) {\n\n  # Set options for joint distribution, drawing, and output\n  draw = opt[1];\n  out = opt[2];\n\n  # Determine line and point characteristics\n  tmp = point_defaults( plt )\n  lnDefaults = tmp[[1]]\n  ptDefaults = tmp[[2]]\n\n  # If there is no grouping variable\n  if ( length( grp ) == 0 ) {\n\n    q = quantile( rt, prob = prb )\n    CAF = sapply( q, function(q) sum( ch[rt < q] )/sum( rt < q ) )\n\n  }\n  # If there is a grouping variable\n  if ( length( grp ) == length( rt ) ) {\n\n    allQ = aggregate( rt, list( grp ), quantile, prob = prb )\n    colnames( allQ ) = c( 'G', 'Q' )\n\n    all_grp = sort( unique( grp ) )\n    allCAF = matrix( NA, nrow( allQ ), ncol( allQ$Q ) )\n    for (i in 1:nrow(allQ)) {\n      chg = ch[ grp == all_grp[i] ]\n      ct = rt[ grp == all_grp[i] ]\n      allCAF[i,] = sapply( allQ$Q[i,],\n                           function(q) {\n                             sum( chg[ct < q] )/sum( ct < q )\n                           } )\n    }\n\n    q = colMeans( allQ$Q )\n    CAF = colMeans( allCAF )\n\n  }\n\n  if (draw) {\n    lines( q, CAF, lty = lnDefaults$lty, lwd = lnDefaults$lwd,\n           col = lnDefaults$col, type = lnDefaults$type )\n    points( q, CAF, pch = ptDefaults$pch,\n            bg = ptDefaults$bg, lwd = ptDefaults$lwd,\n            col = ptDefaults$col, cex = ptDefaults$cex,\n            type = ptDefaults$type )\n  }\n\n  if (out) return( cbind( prb = prb, q = q, CAF = CAF ) )\n}\n\n# Lookup - 06\n#' Blank response time plot\n#'\n#' Creates a blank response time plot with standard labels.\n#'\n#' @param xDim the minimum and maximum x-axis values.\n#' @param yDim the minimum and maximum y-axis values.\n#' @param ver the type of plot to draw (e.g. 'CDF', 'PDF',\n#'   'QPE', or 'CAF').\n#' @param unit the unit for the response times (e.g. 'ms' or 's').\n#' @return A blank response time plot.\n#' @export\n\nblankRTplot = function( xDim = c(0,2), yDim = c(0,1),\n                        ver = 'CDF', unit = 's', ... ) {\n\n  if (ver == 'CDF') {\n    plot( xDim, yDim, type = 'n',\n          ylab = 'Cumulative probability',\n          xlab = paste('RT (',unit,')',sep=''), ... )\n  }\n  if (ver == 'PDF') {\n    plot( xDim, yDim, type = 'n',\n          ylab = 'Density',\n          xlab = paste('RT (',unit,')',sep=''), ... )\n  }\n  if (ver == 'QPE') {\n    plot( xDim, yDim, type = 'n',\n          ylab = 'Cumulative probability',\n          xlab = paste('RT (',unit,')',sep=''), ... )\n  }\n  if (ver == 'CAF') {\n    plot( xDim, yDim, type = 'n',\n          ylab = 'Conditional accuracy',\n          xlab = paste('RT (',unit,')',sep=''), ... )\n  }\n\n}\n",
    "created" : 1470865420129.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1743580069",
    "id" : "1EE66D6D",
    "lastKnownWriteTime" : 1470956902,
    "path" : "F:/Stuff/Kevin's Stuff/Postdoc/R packages/rtplots/R/rt_plot_functions.R",
    "project_path" : "R/rt_plot_functions.R",
    "properties" : {
        "tempName" : "Untitled2"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "type" : "r_source"
}