{
    "contents" : "#----------------------------------#\n# Functions for plotting data from #\n# simple choice and response time  #\n# tasks                            #\n#----------------------------------#\n\n# Index\n# Lookup - 01:  cdf_curve\n# Lookup - 02:  pdf_curve\n# Lookup - 03:  hazard_curve\n# Lookup - 04:  quantile_points\n# Lookup - 05:  caf_points\n# Lookup - 06:  add_points\n# Lookup - 07:  add_points\n# Lookup - 08:  blankRTplot\n# Lookup - 09:  pvt_points\n# Lookup - 10:  add_uncertainty\n\n### TO DO ###\n# Add examples for pvt_points\n# Extend uncertainty intervals for pvt_points\n# Adjust output for 'add_' functions\n# Check man pages for errors\n# Write script testing the functions\n\n# Useful functions for package creation\n# library(devtools)\n# library(roxygen2)\n\n# Lookup - 01\n#' CDF curves for response time and choice data\n#'\n#' Draws a line for the empirical CDF of a set of response\n#' times (conditioned on choice) on an already existing plot.\n#'\n#' @param rt vector of response times.\n#' @param ch a vector of binary choices (i.e. 0 or 1).\n#' @param sel If 0, the CDF for responses times when choice = 0 is\n#'   drawn. If 1, the CDF for responses times when choice = 1 is drawn.\n#' @param grp an optional vector with a grouping factor (e.g. subjects).\n#' @param opt a list of named options:\n#'   \\describe{\n#'     \\item{\\code{jnt}}{If true, the joint distribution is used.}\n#'     \\item{\\code{draw}}{If true, the curve is drawn.}\n#'     \\item{\\code{out}}{If true, output is returned.}\n#'     \\item{\\code{flip}}{If true, the curve is flipped about the\n#'       x-axis.}\n#'   }\n#' @param ... additional plotting parameters.\n#' @return A list consisting of ...\n#' \\describe{\n#'   \\item{\\code{pv}}{a data frame with the plotting values\n#'     used for the x-axis and the y-axis.}\n#'   \\item{\\code{g}}{when a grouping factor is present, a list\n#'     with the matrix of y-axis values per level, the vector\n#'     of associated response times, and the total number of\n#'     observations per each included level.}\n#'   \\item{\\code{v}}{a list of additional variables, the total\n#'     number of observations for all levels, the choice proportion\n#'     for each level, and the choice selection.}\n#'   \\item{\\code{i}}{a list of the input variables.}\n#'   \\item{\\code{opt}}{a list of the options used.}\n#'   }\n#' @examples\n#' # Load in example dataset\n#' data(\"priming_data\")\n#' d = priming_data\n#' layout( cbind(1,2) )\n#' # Single subject\n#' sel = d$Condition == 4 & d$Subject == 1\n#' rt = d$RT[sel]; ch = d$Accuracy[sel]\n#' blankRTplot()\n#' cdf_curve( rt, ch )\n#' cdf_curve( rt, ch, sel = 0, lty = 2 )\n#' # Aggregating over multiple subjects\n#' sel = d$Condition == 0 # Not all subjects had responses for each choice\n#' rt = d$RT[sel]; ch = d$Choice[sel]; grp = d$Subject[sel]\n#' blankRTplot( bty = 'l', ver = 'CDF', cex.axis = 1.5, cex.lab = 1.5 )\n#' cdf_curve( rt, ch, grp = grp, lwd = 2 )\n#' cdf_curve( rt, ch, sel = 0, grp = grp, lwd = 2, lty = 2 )\n#' @export\n\ncdf_curve = function( rt, ch, sel = 1, grp = NULL,\n                      opt = list( ), ... ) {\n\n  # Set options for joint distribution, drawing, output, and\n  # whether curve should be flipped around x-axis\n  if ( length( opt$jnt ) == 0 ) jnt = T else jnt = opt$jnt\n  if ( length( opt$draw ) == 0 ) draw = T else draw = opt$draw\n  if ( length( opt$out ) == 0 ) out = F else out = opt$out\n  if ( length( opt$flip ) == 0 ) flip = F else flip = opt$flip\n  # Save options\n  optOut = list( jnt = jnt, draw = draw,\n                 out = out, flip = flip )\n\n  # If there is no grouping variable\n  if ( length( grp ) == 0 ) {\n\n    # Total number of observations\n    n = sum( ch == sel )\n    if ( n < 1 ) stop('No observations')\n\n    # Empirical estimate of CDF for response times\n    p = (1:n)/n\n    x = sort( rt[ ch == sel ] )\n\n    # Adjust asymptote if estimating joint CDF\n    adj = n/length(ch)\n    if (jnt) p = p*adj;\n\n    # Create list for output\n    output = list(\n      # Save plotting values\n      pv = as.data.frame( cbind( x = x, y = p ) ),\n      # Save grouping factor info\n      g = NULL,\n      # Save variables for calculations\n      v = list( n = n, adj = adj, sel = sel ),\n      # Save input\n      i = as.data.frame( cbind( rt = rt, ch = ch ) ),\n      # Save options\n      opt = optOut\n    )\n\n  }\n  # If there is a grouping variable\n  if ( length( grp ) == length( rt ) ) {\n\n    # Determine number of observations per level of\n    # grouping factor\n    n = aggregate( ch == sel, list( grp ), sum )$x\n    # Determine if there are sufficient observations\n    cmp = round( mean(n) )\n    if (cmp < 1) stop('Not enough observations')\n\n    # Determine number of points to use to estimate CDF\n    if ( cmp < 20 ) seqL = cmp\n    if ( cmp >= 20 & cmp < 100 ) seqL = 20;\n    if ( cmp >= 100 ) seqL = 100;\n\n    # Condition on choice\n    xAll = rt[ ch == sel ]\n    g = grp[ ch == sel ]\n\n    # Determine range to estimate CDF\n    xRange = aggregate( xAll, list( g ),\n                        function(x) c( min(x), max(x) ) )\n    tmp = colMeans( xRange$x )\n\n    # Generate sequence of times over which to calculate\n    # curve\n    xVal = seq( tmp[1], tmp[2], length = seqL  )\n\n    # Determine empirical CDF for each subject\n    pAll = matrix( NA, length( unique( g ) ), seqL  )\n    for (i in 1:seqL ) {\n\n      cnt = sapply( xAll, function(x) x < xVal[i] )\n      pAll[,i] = aggregate( cnt, list( g ), sum )$x/n[ n > 0 ]\n\n    }\n\n    # Aggregate over subjects\n    tot = aggregate( rep(1,length(rt)), list( grp ), sum )$x\n    adj = n[ n > 0 ]/tot[ n > 0 ]\n\n    # Adjust asymptote if estimating joint CDF\n    if (jnt) pAll = pAll*adj;\n\n    x = xVal\n    p = colMeans( pAll )\n\n    # Create list for output\n    output = list(\n      # Save plotting values\n      pv = as.data.frame( cbind( x = x, y = p ) ),\n      # Save grouping factor info\n      g = list( w = pAll, x = xVal, n = n[ n > 0 ] ),\n      # Save variables for calculations\n      v = list( n = n, adj = adj, sel = sel ),\n      # Save input\n      i = as.data.frame( cbind( rt = rt, ch = ch, grp = grp ) ),\n      # Save options\n      opt = optOut\n    )\n\n  }\n\n  if (draw) {\n    if (flip) lines( x, -p, ... ) else lines( x, p, ... )\n  }\n\n  if (out) return( output )\n}\n\n# Lookup - 02\n#' PDF curves for response time and choice data\n#'\n#' Draws a line for the estimated PDF of a set response\n#' times (conditioned on choice) on an already existing plot.\n#'\n#' @param rt vector of response times.\n#' @param ch a vector of binary choices (i.e. 0 or 1).\n#' @param sel If 0, the PDF for responses times when choice = 0 is\n#'   drawn. If 1, the PDF for responses times when choice = 1 is drawn.\n#' @param grp an optional vector with a grouping factor (e.g. subjects).\n#' @param opt a list of named options:\n#'   \\describe{\n#'     \\item{\\code{jnt}}{If true, the joint distribution is used.}\n#'     \\item{\\code{draw}}{If true, the curve is drawn.}\n#'     \\item{\\code{out}}{If true, output is returned.}\n#'     \\item{\\code{flip}}{If true, the curve is flipped about the\n#'       x-axis.}\n#'   }\n#' @param ...  additional plotting parameters.\n#' @return A list consisting of...\n#' \\describe{\n#'   \\item{\\code{pv}}{a data frame with the plotting values\n#'     used for the x-axis and the y-axis.}\n#'   \\item{\\code{g}}{when a grouping factor is present, a list\n#'     with the matrix of y-axis values per level, the vector\n#'     of associated response times, and the total number of\n#'     observations per each included level}\n#'   \\item{\\code{v}}{a list of additional variables, the total\n#'     number of observations for all levels, the choice proportion\n#'     for each level, the choice selection, and when there\n#'     is no grouping factor, the response times and their\n#'     associated estimated density.}\n#'   \\item{\\code{i}}{a list of the input variables.}\n#'   \\item{\\code{opt}}{a list of the options used.}\n#'   }\n#' @examples\n#' # Load in example dataset\n#' data(\"priming_data\")\n#' d = priming_data\n#' layout( cbind(1,2) )\n#' # Single subject\n#' sel = d$Condition == 4 & d$Subject == 1\n#' rt = d$RT[sel]; ch = d$Accuracy[sel]\n#' blankRTplot( pDim = c(0,4), ver='PDF' )\n#' pdf_curve( rt, ch )\n#' pdf_curve( rt, ch, sel = 0, lty = 2 )\n#' # Aggregating over multiple subjects\n#' sel = d$Condition == 0 # Not all subjects had responses for each choice\n#' rt = d$RT[sel]; ch = d$Choice[sel]; grp = d$Subject[sel]\n#' blankRTplot( bty = 'l', ver = 'PDF', pDim = c(0,4), cex.axis = 1.5, cex.lab = 1.5 )\n#' pdf_curve( rt, ch, grp = grp, lwd = 2 )\n#' pdf_curve( rt, ch, sel = 0, grp = grp, lwd = 2, lty = 2 )\n#' @export\n\npdf_curve = function( rt, ch, sel = 1, grp = NULL,\n                      opt = list( ), ... ) {\n\n  # Set options for joint distribution, drawing, output, and\n  # whether curve should be flipped around x-axis\n  if ( length( opt$jnt ) == 0 ) jnt = T else jnt = opt$jnt\n  if ( length( opt$draw ) == 0 ) draw = T else draw = opt$draw\n  if ( length( opt$out ) == 0 ) out = F else out = opt$out\n  if ( length( opt$flip ) == 0 ) flip = F else flip = opt$flip\n  # Save options\n  optOut = list( jnt = jnt, draw = draw,\n                 out = out, flip = flip )\n\n  # If there is no grouping variable\n  if ( length( grp ) == 0 ) {\n\n    n = sum( ch == sel ) # Determine number of observations\n\n    if ( n < 2 ) stop('Not enough observations')\n\n    # Estimate density using base R\n    xa = sort( rt[ ch == sel ] )\n    dn = density( xa )\n    x = dn$x; d = dn$y\n    # Bound by minimum and maximum RT\n    lb = min( rt[ ch == sel ] )\n    ub = max(rt[ ch == sel ] )\n    kp = x >= lb & x <= ub\n    x = x[kp]; d = d[kp]\n\n    # Weight density for joint pdf\n    adj = mean( ch == sel )\n    if (jnt) d = d*adj\n\n    # Extract density estimates for the set of\n    # observed response times\n    df = approxfun(dn) # Approximates density function\n    vl = df(xa) # Calculates density for observed data\n    if (jnt) vl = vl*adj\n\n    # Create list for output\n    output = list(\n      # Save plotting values\n      pv = as.data.frame( cbind( x = x, y = d ) ),\n      # Save grouping factor info\n      g = NULL,\n      # Save variables for calculations\n      v = list( n = n, adj = adj, sel = sel, rt = xa, d = vl ),\n      # Save input\n      i = as.data.frame( cbind( rt = rt, ch = ch ) ),\n      # Save options\n      opt = optOut\n    )\n\n  }\n  # If there is a grouping variable\n  if ( length( grp ) == length( rt ) ) {\n\n    # Determine number of observations per level of\n    # grouping factor\n    n = aggregate( ch == sel, list( grp ), sum )\n    # Determine if there are sufficient observations\n    cmp = round( mean(n$x) )\n    if (cmp < 2) stop('Not enough observations')\n\n    # Condition on choice\n    cur_t = rt[ ch == sel ]\n    cur_grp = grp[ ch == sel ]\n\n    # Skip subjects without a sufficient number of observations\n    rmv = n[ n$x < 2, 1 ]\n    if ( length( rmv ) > 0 ) {\n      for (i in 1:length(rmv) ) cur_grp = cur_grp[ cur_grp != rmv[i] ]\n    }\n\n    # Determine range of response times over which to\n    # estimate density\n    x = seq( min(cur_t), quantile( cur_t, .99), length = 100 )\n    # Levels of the grouping factor\n    all_grp = sort( unique( cur_grp ) )\n\n    # Calculate density for each level of grouping factor\n    all_dn = matrix( 0, length( all_grp ), 100 )\n    for (g in 1:length(all_grp) ) {\n\n      dn = density( cur_t[ cur_grp == all_grp[g] ] )\n\n      # Extract density estimates for each response time\n      df = approxfun(dn) # Approximates density function\n      all_dn[g,] = df(x);\n\n    }\n    all_dn[is.na( all_dn )] = 0\n\n    # Weight density for joint pdf\n    adj = aggregate( ch, list( grp ), function(x) mean(x == sel) )$x\n    # Remove subjects without sufficient number of observations\n    adj = adj[ n$x >= 2 ]\n    if (jnt) all_dn = all_dn*adj;\n\n    # Aggregate over subjects\n    d = colMeans( all_dn )\n\n    dn = all_dn\n\n    # Create list for output\n    output = list(\n      # Save plotting values\n      pv = as.data.frame( cbind( x = x, y = d ) ),\n      # Save grouping factor info\n      g = list( w = all_dn, x = x, n = n$x[ n$x >= 2 ] ),\n      # Save variables for calculations\n      v = list( n = n$x, adj = adj, sel = sel ),\n      # Save input\n      i = as.data.frame( cbind( rt = rt, ch = ch, grp = grp ) ),\n      # Save options\n      opt = optOut\n    )\n\n  }\n\n  if (draw) {\n    if (flip) lines( x, -d, ... ) else lines( x, d, ... )\n  }\n\n  if (out) return( output )\n}\n\n# Lookup - 03\n#' Estimated the hazard function for response time and choice data\n#'\n#' Draws a smoothed estimate of the hazard function for a set of\n#' response times (conditioned on choice) using an algorithm\n#' recommended by Luce (1986, see equations 4.1 and 4.2).\n#'\n#' @param rt vector of response times.\n#' @param ch a vector of binary choices (i.e. 0 or 1).\n#' @param sel If 0, the hazard function for responses times when choice = 0 is\n#'   drawn. If 1, the hazard function for responses times when choice = 1 is\n#'   drawn.\n#' @param prb the sequence of cumulative probabilities used to define\n#'   the intervals.\n#' @param j a parameter controlling the degree of smoothing.\n#' @param opt a list of named options:\n#'   \\describe{\n#'     \\item{\\code{jnt}}{If true, the joint distribution is used.}\n#'     \\item{\\code{draw}}{If true, the curve is drawn.}\n#'     \\item{\\code{out}}{If true, output is returned.}\n#'     \\item{\\code{flip}}{If true, the curve is flipped about the\n#'       x-axis.}\n#'   }\n#' @param ...  additional plotting parameters.\n#' @references Luce, R. D. (1986). Response Times: Their Role in Inferring\n#'   Elementary Mental Organization. New York: Oxford University Press.\n#' @return A list consisting of ...\n#' \\describe{\n#'   \\item{\\code{pv}}{a data frame with the plotting values\n#'     used for the x-axis and the y-axis.}\n#'   \\item{\\code{g}}{when a grouping factor is present, a list\n#'     with the matrix of y-axis values per level and the matrix\n#'     of quantiles for each level.}\n#'   \\item{\\code{v}}{a list of additional variables, the total\n#'     number of observations for all levels, the choice proportion\n#'     for each level, the choice selection, the smoothing\n#'     parameter j, and the cumulative probabilities used to\n#'     define the intervals.}\n#'   \\item{\\code{i}}{a list of the input variables.}\n#'   \\item{\\code{opt}}{a list of the options used.}\n#'   }\n#' @export\n#' @examples\n#' #' # Load in example dataset\n#' data(\"priming_data\")\n#' d = priming_data\n#' layout( cbind(1,2) )\n#' # Single subject\n#' sel = d$Condition == 4 & d$Subject == 1\n#' rt = d$RT[sel]; ch = d$Accuracy[sel]\n#' blankRTplot( pDim = c(0,5), ver='HF' )\n#' hazard_curve( rt, ch )\n#' hazard_curve( rt, ch, sel = 0, lty = 2 )\n#' # Aggregating over multiple subjects\n#' sel = d$Condition == 4\n#' rt = d$RT[sel]; ch = d$Choice[sel]; grp = d$Subject[sel]\n#' blankRTplot( bty = 'l', ver = 'HF', pDim = c(0,5), cex.axis = 1.5, cex.lab = 1.5 )\n#' hazard_curve( rt, ch, grp = grp, lwd = 2 )\n#' hazard_curve( rt, ch, sel = 0, grp = grp, lwd = 2, lty = 2 )\n\nhazard_curve = function( rt, ch, sel = 1, prb = seq(.05,.95,.1),\n                         j = 25, grp = NULL, opt = list( ), ... ) {\n\n  # Set options for joint distribution, drawing, output, and\n  # whether curve should be flipped around x-axis\n  if ( length( opt$jnt ) == 0 ) jnt = F else jnt = opt$jnt\n  if ( length( opt$draw ) == 0 ) draw = T else draw = opt$draw\n  if ( length( opt$out ) == 0 ) out = F else out = opt$out\n  if ( length( opt$flip ) == 0 ) flip = F else flip = opt$flip\n  # Save options\n  optOut = list( jnt = jnt, draw = draw,\n                 out = out, flip = flip )\n\n  # Equation 4.2 from Luce (1986)\n  S = function( n, k, Z ) {\n\n    Z_k = Z[k]\n    if (k == 1) Z_km1 = 0 else Z_km1 = Z[k-1]\n\n    out = ( n - k + 1 ) * ( Z_k - Z_km1 )\n\n    return( out )\n  }\n\n  # Equation 4.1 from Luce (1986)\n  l_hat = function(i,j,n,Z) {\n\n    beg = i - j + 1; if (beg < 1) { beg = 1; j = i }\n    denom = numeric( i - beg )\n\n    inc = 1;\n    for ( k in beg:i ) { denom[inc] = S( n, k, Z ); inc = inc + 1 }\n    out = j/sum( denom )\n\n    return( out )\n  }\n\n  # Function to determine total number of observations\n  # less than or equal to a particular value\n  f = function(q) return( sum( Z <= q ) )\n\n  # If there is no grouping variable\n  if ( length( grp ) == 0 ) {\n\n    n = sum( ch == sel ) # Determine number of observations\n    if ( n < length(prb) ) stop('Not enough observations')\n\n    # Condition on choice\n    x = rt[ ch == sel ]\n\n    # Determine number of intervals\n    Z = sort( x ) # Sort observations\n    q = quantile( x, prob = prb )\n    int = sapply( q, f )\n\n    # Estimate a smoothed version of the hazard function\n    h = sapply( int, l_hat, j = j, n = n, Z = Z )\n    x = Z[ int ];\n\n    # Adjustment for joint distributions\n    adj = mean( ch == sel )\n    if (jnt) h = h*adj\n\n    # Create list for output\n    output = list(\n      # Save plotting values\n      pv = as.data.frame( cbind( x = x, y = h ) ),\n      # Save grouping factor info\n      g = NULL,\n      # Save variables for calculations\n      v = list( n = n, adj = adj, sel = sel, j = j, prb = prb ),\n      # Save input\n      i = as.data.frame( cbind( rt = rt, ch = ch ) ),\n      # Save options\n      opt = optOut\n    )\n\n  }\n  # If there is a grouping variable\n  if ( length( grp ) == length( rt ) ) {\n\n    # Determine number of observations per level of\n    # grouping factor\n    n = aggregate( ch == sel, list( grp ), sum )\n    # Adjust estimate of curve based on\n    # average number of observations\n    cmp = round( mean(n$x) )\n    if (cmp < 2) stop('Not enough observations')\n\n    # Condition on choice\n    xAll = rt[ ch == sel ]\n    gAll = grp[ ch == sel ]\n    nAll = n$x[ n$x > 0 ]\n\n    # Calculate group quantiles\n    qAll = aggregate( xAll, list( gAll ), quantile, prob = prb )\n    colnames( qAll ) = c('G','Q')\n    q = colMeans( qAll$Q )\n\n    hAll = matrix( 0, nrow( qAll ), ncol( qAll$Q ) )\n\n    for ( i in 1:nrow( qAll ) ) {\n\n      # Determine number of intervals\n      Z = sort( xAll[ gAll == qAll$G[i] ] ) # Sort observations\n      int = sapply( q, f )\n\n      ind = min( which( int > 0 ) ):length(q)\n\n      # Estimate a smoothed version of the hazard function\n      hAll[i,ind] = sapply( int[ind], l_hat, j = j, n = nAll[i], Z = Z )\n      print( hAll[i,] )\n\n    }\n\n    h = colMeans( hAll )\n    x = q\n\n    # Adjustment for joint distributions\n    adj = mean( ch == sel )\n    if (jnt) h = h*adj\n\n    # Create list for output\n    output = list(\n      # Save plotting values\n      pv = as.data.frame( cbind( x = x, y = h ) ),\n      # Save grouping factor info\n      g = list( w = hAll, x = qAll ),\n      # Save variables for calculations\n      v = list( n = n, adj = adj, sel = sel, j = j, prb = prb ),\n      # Save input\n      i = as.data.frame( cbind( rt = rt, ch = ch, grp = grp ) ),\n      # Save options\n      opt = optOut\n    )\n\n  }\n\n  if (draw) {\n    if (flip) lines( x, -h, ... ) else lines( x, h, ... )\n  }\n\n  if (out) return( output )\n}\n\n# Lookup - 04\n#' Quantile-probability estimates\n#'\n#' Draws the estimated quantiles based on the corresponding\n#' cumulative probabilities for a set of response times\n#' (conditioned on choice).\n#'\n#' @param rt vector of response times.\n#' @param ch a vector of binary choices (i.e. 0 or 1).\n#' @param sel If 0, the quantile-probability estimates for responses\n#'   times when choice = 0 are drawn. If 1, the quantile-probability\n#'   estimates for responses times when choice = 1 are drawn.\n#' @param prb the sequence of cumulative probabilities for which the\n#'   quantiles should be determined.\n#' @param grp an optional vector with a grouping factor (e.g. subjects).\n#' @param opt a list of named options:\n#'   \\describe{\n#'     \\item{\\code{jnt}}{If true, the joint distribution is used.}\n#'     \\item{\\code{draw}}{If true, the curve is drawn.}\n#'     \\item{\\code{out}}{If true, output is returned.}\n#'     \\item{\\code{flip}}{If true, the curve is flipped about the\n#'       x-axis.}\n#'     \\item{\\code{pts}}{If true, draw points instead of lines.}\n#'   }\n#' @param ...  additional plotting parameters.\n#' @return A list consisting of...\n#' \\describe{\n#'   \\item{\\code{pv}}{a data frame with the plotting values\n#'     used for the x-axis and the y-axis.}\n#'   \\item{\\code{g}}{when a grouping factor is present, a list\n#'     with the matrix of y-axis values per level and the\n#'     associated matrix of quantiles.}\n#'   \\item{\\code{v}}{a list of additional variables, the choice\n#'     proportion for each level and the choice selection.}\n#'   \\item{\\code{i}}{a list of the input variables.}\n#'   \\item{\\code{opt}}{a list of the options used.}\n#'   }\n#' @examples\n#' # Load in example dataset\n#' data(\"priming_data\")\n#' d = priming_data\n#' layout( cbind(1,2) )\n#' # Single subject\n#' sel = d$Condition == 6 & d$Subject == 20\n#' rt = d$RT[sel]; ch = d$Accuracy[sel]\n#' blankRTplot( tDim = c(0,1) )\n#' quantile_points( rt, ch, opt = list( pts = F ) )\n#' quantile_points( rt, ch, pch = 21, bg = 'white' )\n#' quantile_points( rt, ch, sel = 0, opt = list( pts = F ), lty = 2 )\n#' quantile_points( rt, ch, sel = 0, pch = 24, bg = 'white' )\n#' # Aggregating over multiple subjects\n#' sel = d$Condition == 6\n#' rt = d$RT[sel]; ch = d$Choice[sel]; grp = d$Subject[sel]\n#' blankRTplot( tDim = c(0,1), bty = 'l', cex.axis = 1.5, cex.lab = 1.5 )\n#' quantile_points( rt, ch, grp = grp, opt = list( pts = F ), lwd = 2 )\n#' quantile_points( rt, ch, grp = grp, pch = 21, bg = 'white', cex = 1.2 )\n#' quantile_points( rt, ch, sel = 0, grp = grp, opt = list( pts = F ), lwd = 2, lty = 2 )\n#' quantile_points( rt, ch, sel = 0, grp = grp, pch = 24, bg = 'white', cex = 1.2 )\n#' @export\n\nquantile_points = function( rt, ch, sel = 1,\n                            prb = seq( .1, .9, .2 ), grp = NULL,\n                            opt = list( ), ... ) {\n\n  # Set options for joint distribution, drawing, output, and\n  # whether curve should be flipped around x-axis\n  if ( length( opt$jnt ) == 0 ) jnt = T else jnt = opt$jnt\n  if ( length( opt$draw ) == 0 ) draw = T else draw = opt$draw\n  if ( length( opt$out ) == 0 ) out = F else out = opt$out\n  if ( length( opt$flip ) == 0 ) flip = F else flip = opt$flip\n  if ( length( opt$pts ) == 0 ) pts = T  else pts = opt$pts\n  # Save options\n  optOut = list( jnt = jnt, draw = draw,\n                 out = out, flip = flip, pts = pts )\n\n  # If there is no grouping variable\n  if ( length( grp ) == 0 ) {\n\n    # Total number of observations\n    n = sum( ch == sel )\n    if ( n < 1 ) stop('No observations')\n\n    # Condition on choice\n    x = rt[ ch == sel ]\n\n    # Calculate adjustment for joint distribution\n    adj = mean( ch == sel )\n\n    # Calculate quantiles\n    q = quantile( x, prob = prb )\n    if (jnt) p = prb*adj else p = prb\n\n    output = list( pv = cbind( x = q, y = p ),\n                   g = NULL,\n                   v = list(adj = adj, sel = sel),\n                   i = list( rt = rt, ch = ch ),\n                   opt = optOut )\n\n  }\n  # If there is a grouping variable\n  if ( length( grp ) == length( rt ) ) {\n\n    # Determine number of observations per level of\n    # grouping factor\n    n = aggregate( ch == sel, list( grp ), sum )$x\n    # Determine if there are sufficient observations\n    cmp = round( mean(n) )\n    if (cmp < 1) stop('Not enough observations')\n\n    # Condition on choice\n    xAll = rt[ ch == sel ]\n    grpAll = grp[ ch == sel ]\n\n    # Calculate quantiles over levels of grouping factor\n    allQ = aggregate( xAll, list( grpAll ), quantile, prob = prb )\n    colnames( allQ ) = c('G','Q')\n\n    # Calculate adjustment for joint distribution over\n    # levels of grouping factor\n    adj = aggregate( ch, list( grp ), function(x) mean(x == sel) )\n    y = matrix( prb, nrow(allQ), length(prb), byrow = T )\n    if (jnt) y = y*adj$x;\n\n    q = colMeans( allQ$Q )\n    p = colMeans( y )\n\n    output = list( pv = cbind( x = q, y = p ),\n                   g = list( w = y, x = allQ$Q ),\n                   v = list(adj = adj$x, sel = sel),\n                   i = list( rt = rt, ch = ch, grp = grp ),\n                   opt = optOut )\n  }\n\n  if (draw) {\n    if (pts) {\n      if (flip) points( q, -p, ... ) else points( q, p, ... )\n    } else {\n      if (flip) lines( q, -p, ... ) else lines( q, p, ... )\n    }\n  }\n\n  if (out) return( output )\n}\n\n# Lookup - 05\n#' Conditional accuracy function\n#'\n#' Draws the conditional accuracy at different response time quantiles.\n#'\n#' @param rt vector of response times.\n#' @param ch a vector of binary choices (i.e. 0 or 1).\n#' @param prb the sequence of cumulative probabilities for which the\n#'   quantiles should be determined.\n#' @param grp an optional vector with a grouping factor (e.g. subjects).\n#' @param opt a list of named options:\n#'   \\describe{\n#'     \\item{\\code{jnt}}{If true, the joint distribution is used.}\n#'     \\item{\\code{draw}}{If true, the curve is drawn.}\n#'     \\item{\\code{out}}{If true, output is returned.}\n#'     \\item{\\code{flip}}{If true, the curve is flipped about the\n#'       x-axis.}\n#'     \\item{\\code{pts}}{If true, draw points instead of lines.}\n#'   }\n#' @param ...  additional plotting parameters.\n#' @return A list consisting of...\n#' \\describe{\n#'   \\item{\\code{pv}}{a data frame with the plotting values\n#'     used for the x-axis and the y-axis.}\n#'   \\item{\\code{g}}{when a grouping factor is present, a list\n#'     with the matrix of y-axis values per level and the\n#'     associated matrix of quantiles.}\n#'   \\item{\\code{v}}{a list of additional variables, the choice\n#'     proportion for each level and the choice selection.}\n#'   \\item{\\code{i}}{a list of the input variables.}\n#'   \\item{\\code{opt}}{a list of the options used.}\n#'   }\n#' @examples\n#' # Load in example dataset\n#' data(\"priming_data\")\n#' d = priming_data\n#' layout( cbind(1,2) )\n#' # Single subject\n#' sel = d$Condition == 12 & d$Subject == 7\n#' rt = d$RT[sel]; ch = d$Accuracy[sel]\n#' blankRTplot( tDim = c(.6,1.6), ver = 'CAF' )\n#' caf_points( rt, ch, opt = list( pts = F ) )\n#' caf_points( rt, ch, pch = 21, bg = 'white' )\n#' # Aggregating over multiple subjects\n#' sel = d$Condition == 12\n#' rt = d$RT[sel]; ch = d$Choice[sel]; grp = d$Subject[sel]\n#' blankRTplot( tDim = c(0,1.2), ver = 'CAF', cex.axis = 1.5, cex.lab = 1.5 )\n#' caf_points( rt, ch, grp = grp, opt = list( pts = F ), lwd = 2 )\n#' caf_points( rt, ch, grp = grp, pch = 21, bg = 'white', cex = 1.2 )\n#' @export\n\ncaf_points = function( rt, ch, prb = seq( .1, .9, .2 ),\n                       grp = NULL, opt = list( ), ... ) {\n\n  # Set options for joint distribution, drawing, output, and\n  # whether curve should be flipped around x-axis\n  if ( length( opt$jnt ) == 0 ) jnt = T else jnt = opt$jnt\n  if ( length( opt$draw ) == 0 ) draw = T else draw = opt$draw\n  if ( length( opt$out ) == 0 ) out = F else out = opt$out\n  if ( length( opt$flip ) == 0 ) flip = F else flip = opt$flip\n  if ( length( opt$pts ) == 0 ) pts = T  else pts = opt$pts\n  # Save options\n  optOut = list( jnt = jnt, draw = draw,\n                 out = out, flip = flip, pts = pts )\n\n  # If there is no grouping variable\n  if ( length( grp ) == 0 ) {\n\n    q = quantile( rt, prob = prb )\n    ca = sapply( q, function(q) sum( ch[rt < q] )/sum( rt < q ) )\n\n    output = list( pv = cbind( x = q, y = ca ),\n                   g = NULL,\n                   v = list( prb = prb ),\n                   i = list( rt = rt, ch = ch ),\n                   opt = optOut )\n\n  }\n  # If there is a grouping variable\n  if ( length( grp ) == length( rt ) ) {\n\n    allQ = aggregate( rt, list( grp ), quantile, prob = prb )\n    colnames( allQ ) = c( 'G', 'Q' )\n\n    all_grp = sort( unique( grp ) )\n    allCAF = matrix( NA, nrow( allQ ), ncol( allQ$Q ) )\n    for (i in 1:nrow(allQ)) {\n      chg = ch[ grp == all_grp[i] ]\n      ct = rt[ grp == all_grp[i] ]\n      allCAF[i,] = sapply( allQ$Q[i,],\n                           function(q) {\n                             sum( chg[ct < q] )/sum( ct < q )\n                           } )\n    }\n\n    q = colMeans( allQ$Q )\n    ca = colMeans( allCAF )\n\n    output = list( pv = cbind( x = q, y = ca ),\n                   g = list( w = allCAF, x = allQ$Q ),\n                   v = list( prb = prb ),\n                   i = list( rt = rt, ch = ch, grp = grp ),\n                   opt = optOut )\n\n  }\n\n  if (draw) {\n    if (pts) {\n      if (flip) points( q, -ca, ... ) else points( q, ca, ... )\n    } else {\n      if (flip) lines( q, -ca, ... ) else lines( q, ca, ... )\n    }\n  }\n\n  if (out) return( output )\n}\n\n# Lookup - 06\n#' Add additional points\n#'\n#' Adds additional points to an existing plot, drawing a given\n#' test statistic for response times conditioned on choice using\n#' output from a curve function.\n#'\n#' @param output the list output from \\code{cdf_curve},\n#'   \\code{pdf_curve}, or \\code{hazard_curve}.\n#' @param T_x a function to calculate a text statistic over\n#'   a vector (e.g. mean, median, etc.).\n#' @param out A logical value, indicating if output should be returned.\n#' @param ...  additional plotting parameters.\n#' @return A list consisting of the x and y-axis plotting points.\n#' @examples\n#' # Load in example dataset\n#' data(\"priming_data\")\n#' d = priming_data\n#' layout( cbind(1,2) )\n#' # Single subject\n#' sel = d$Condition == 15 & d$Subject == 1\n#' rt = d$RT[sel]; ch = d$Accuracy[sel]\n#' blankRTplot()\n#' out = cdf_curve( rt, ch, opt = list( out = T ) )\n#' add_points( out, pch = 19, col = 'blue' )\n#' add_points( out, T_x = median, pch = 19, col = 'red' )\n#' legend( 'topleft', c('Mean','Median'), fill = c('blue','red'), bty = 'n' )\n#' # Aggregating over multiple subjects\n#' sel = d$Condition == 15\n#' rt = d$RT[sel]; ch = d$Choice[sel]; grp = d$Subject[sel]\n#' blankRTplot()\n#' out = cdf_curve( rt, ch, opt = list( out = T ) )\n#' T_x = function(x) quantile(x,prob=seq(.1,.9,.1))\n#' add_points( out, T_x = T_x, pch = 21, bg = 'white' )\n#' @export\n\nadd_points = function( output, T_x = mean, out = F, ... ) {\n\n  # Extract choice to condition on\n  sel = output$v$sel\n  # Extract input\n  rt = output$i$rt; ch = output$i$ch\n  # Extract options on whether to flip\n  flip = output$opt$flip\n\n  # Determine if there is a grouping variable\n  grp = output$i$grp\n\n  # No grouping factor\n  if ( length( grp ) == 0 ) {\n\n    # Condition on choice\n    x = rt[ ch == sel ]\n    # Calculate statistic\n    ts = T_x( x )\n\n  }\n  # Grouping factor\n  if ( length( grp ) == length( rt ) ) {\n\n    # Condition on choice\n    xAll = rt[ ch == sel ]\n    g = grp[ ch == sel ]\n\n    # Calculate statistic\n    tsAll = aggregate( xAll, list( g ), T_x )\n\n    # Collapse over group levels\n    if ( is.matrix( tsAll$x ) ) {\n      ts = colMeans( tsAll$x )\n    } else {\n      ts = mean( tsAll$x )\n    }\n\n  }\n\n  # Extract plotting values\n  xa = output$pv$x # x-axis\n  ya = output$pv$y # y-axis\n\n  # Function to calculate values for y-axis\n  # using linear interpolation\n  f = function( x ) {\n\n    ind = max( which( xa < x ) )\n    if ( ind == -Inf ) {\n      out = ya[1];\n    } else {\n\n      if ( ind == length(xa) ) {\n        out = ya[ length(xa) ]\n      } else {\n        pts = c( ind, ind + 1 )\n        out = lnInterp( x, ya[ pts ], xa[ pts ] )\n      }\n\n    }\n\n    return( out )\n  }\n\n  # Determine y-axis values\n  ny = sapply( ts, f )\n\n  # Save output\n  new_output = list( x = ts, y = ny )\n\n  # Add points\n  if (flip) points( ts, -ny, ... ) else points( ts, ny, ... )\n\n  if (out) return( new_output )\n}\n\n# Lookup - 07\n#' Add additional line segments\n#'\n#' Adds additional vertical line segments to an existing plot,\n#' based on a given test statistic for response times conditioned\n#' on choice using output from a curve function.\n#'\n#' @param output the list output from \\code{cdf_curve},\n#'   \\code{pdf_curve}, or \\code{hazard_curve}.\n#' @param T_x a function to calculate a text statistic over\n#'   a vector (e.g. mean, median, etc.).\n#' @param out A logical value, indicating if output should be returned.\n#' @param ...  additional plotting parameters.\n#' @return A list consisting of the x and y-axis plotting points.\n#' @examples\n#' # Load in example dataset\n#' data(\"priming_data\")\n#' d = priming_data\n#' layout( cbind(1,2) )\n#' # Single subject\n#' sel = d$Condition == 15 & d$Subject == 1\n#' rt = d$RT[sel]; ch = d$Accuracy[sel]\n#' blankRTplot()\n#' out = cdf_curve( rt, ch, opt = list( out = T ) )\n#' add_segments( out, col = 'blue' )\n#' add_segments( out, T_x = median, col = 'red' )\n#' legend( 'topleft', c('Mean','Median'), fill = c('blue','red'), bty = 'n' )\n#' # Aggregating over multiple subjects\n#' sel = d$Condition == 15\n#' rt = d$RT[sel]; ch = d$Choice[sel]; grp = d$Subject[sel]\n#' blankRTplot()\n#' out = cdf_curve( rt, ch, opt = list( out = T ) )\n#' T_x = function(x) quantile(x,prob=seq(.1,.9,.1))\n#' add_points( out, T_x = T_x, col = 'grey' )\n#' @export\n\nadd_segments = function( output, T_x = mean, out = F, ... ) {\n\n  # Extract choice to condition on\n  sel = output$v$sel\n  # Extract input\n  rt = output$i$rt; ch = output$i$ch\n  # Extract options on whether to flip\n  flip = output$opt$flip\n\n  # Determine if there is a grouping variable\n  grp = output$i$grp\n\n  # No grouping factor\n  if ( length( grp ) == 0 ) {\n\n    # Condition on choice\n    x = rt[ ch == sel ]\n    # Calculate statistic\n    ts = T_x( x )\n\n  }\n  # Grouping factor\n  if ( length( grp ) == length( rt ) ) {\n\n    # Condition on choice\n    xAll = rt[ ch == sel ]\n    g = grp[ ch == sel ]\n\n    # Calculate statistic\n    tsAll = aggregate( xAll, list( g ), T_x )\n\n    # Collapse over group levels\n    if ( is.matrix( tsAll$x ) ) {\n      ts = colMeans( tsAll$x )\n    } else {\n      ts = mean( tsAll$x )\n    }\n\n  }\n\n  # Extract plotting values\n  xa = output$pv$x # x-axis\n  ya = output$pv$y # y-axis\n\n  # Function to calculate values for y-axis\n  # using linear interpolation\n  f = function( x ) {\n\n    ind = max( which( xa < x ) )\n    if ( ind == -Inf ) {\n      out = ya[1];\n    } else {\n\n      if ( ind == length(xa) ) {\n        out = ya[ length(xa) ]\n      } else {\n        pts = c( ind, ind + 1 )\n        out = lnInterp( x, ya[ pts ], xa[ pts ] )\n      }\n\n    }\n\n    return( out )\n  }\n\n  # Determine y-axis values\n  ny = sapply( ts, f )\n\n  # Save output\n  new_output = list( x = ts, y = ny )\n\n  # Add line segments\n  if (flip) segments( ts, rep( 0, length(ts) ),\n                      ts, -ny, ... ) else\n                        segments( ts, rep( 0, length(ts) ),\n                                  ts, ny, ... )\n\n  if (out) return( new_output )\n}\n\n# Lookup - 08\n#' Blank response time plot\n#'\n#' Creates a blank response time plot with standard labels.\n#'\n#' @param tDim the minimum and maximum for the time axis.\n#' @param pDim the minimum and maximum for the choice/accuracy/probability\n#'   axis.\n#' @param ver the type of plot to draw (i.e. 'CDF', 'PDF',\n#'   'HF', 'CAF', 'PvT', or 'blank' ).\n#' @param unit the unit for the response times (e.g. 'ms' or 's').\n#' @param ... additional plotting parameters.\n#' @return A blank response time plot.\n#' @examples\n#' layout( rbind( 1:3, 4:6 ) )\n#' blankRTplot(); blankRTplot(ver='PDF');\n#' blankRTplot(ver='CAF'); blankRTplot(ver='HF');\n#' blankRTplot(ver='PvT'); blankRTplot(ver='blank')\n#' @export\n\nblankRTplot = function( tDim = c(0,2), pDim = c(0,1),\n                        ver = 'CDF', unit = 's', ... ) {\n\n  # Define label for x-axis\n  tl = paste( 'RT (', unit, ')', sep = '' )\n\n  if ( ver == 'PvT' ) {\n    pl = 'P(Y = 1)'\n    plot( pDim, tDim, type = 'n', ylab = tl, xlab = pl, ... )\n    return()\n  }\n\n  if ( ver == 'CDF' | ver == 'QPE' ) pl = 'Cumulative probability'\n  if ( ver == 'PDF' ) pl = 'Density'\n  if ( ver == 'CAF' ) pl = 'P( Y = 1 | Q(t) )'\n  if ( ver == 'HF' ) pl = 'Hazard function'\n  if ( ver == 'blank' ) { tl = ' '; pl = ' ' }\n\n  plot( tDim, pDim, type = 'n', ylab = pl, xlab = tl, ... )\n\n}\n\n\n# Lookup - 09\n#' Add points to a P(Y=1) by T(x) plot\n#'\n#' Adds a set of points for a test statistic for response times\n#' calculated over the levels of a covariate against the\n#' probability of picking a '1' response.\n#'\n#' @param rt vector of response times.\n#' @param ch a vector of binary choices (i.e. 0 or 1).\n#' @param grp an optional vector with a grouping factor (e.g. subjects).\n#' @param T_x a function to calculate a text statistic over\n#'   a vector (e.g. mean, median, etc.).\n#' @param plt an optional list giving values for the \\code{pch},\n#'   \\code{col}, and \\code{bg} plotting parameters.\n#' @param opt a list of named options:\n#'   \\describe{\n#'     \\item{\\code{draw}}{If true, the intervals are drawn.}\n#'     \\item{\\code{out}}{If true, output is returned.}\n#'   }\n#' @param ...  additional plotting parameters.\n#' @return A list consisting of ...\n#' \\describe{\n#'   \\item{\\code{pv}}{a list with the plotting values used for\n#'     the x-axis and the y-axis.}\n#'   \\item{\\code{g}}{when a grouping factor is present, a list\n#'     with the data-frame for the y-axis values and the x-axis\n#'     values by group and covariate level.}\n#'   \\item{\\code{i}}{a list of the input variables.}\n#'   \\item{\\code{opt}}{a list of the options used.}\n#'   }\n#' @export\n\npvt_points = function( rt, ch, cvrts, grp = NULL, T_x = mean,\n                       plt = list( ), opt = list( ),\n                       ... ) {\n\n  # Set options for drawing and output\n  if ( length( opt$draw ) == 0 ) draw = T else draw = opt$draw\n  if ( length( opt$out ) == 0 ) out = F else out = opt$out\n  # Save options\n  optOut = list( draw = draw, out = out )\n\n  # If there is no grouping factor\n  if ( length( grp ) == 0 ) {\n\n    # Apply the test statistic to response times\n    # over the covariate levels\n    yv = aggregate( rt, list( cvrts ), T_x )\n    colnames( yv ) = c('Cv','T_x')\n\n    # Calculate the proportion of Y == ch over the\n    # covariate levels\n    xv = aggregate( ch, list( cvrts ), mean )\n    colnames( xv ) = c('Cv','P')\n\n    # Determine the dimensions of the test statistic\n    dmn = dim( yv$T_x )\n\n    plt = pvt_plot_options(plt,dmn,xv)\n\n    if (draw) {\n\n      if ( length( dmn ) > 0 ) {\n        # If the y-axis values are in a matrix\n\n        # Plot the points for each level\n        for (i in 1:dmn[1]) {\n          points( rep( xv$P[i], dmn[2] ),\n                  yv$T_x[i,], pch = plt$pch[i,],\n                  col = plt$col[i,],\n                  bg = plt$bg[i,], ... )\n        }\n\n      } else {\n        # If the y-axis values are in a vector\n\n        # Plot the point for each level\n        points( xv$P, yv$T_x, pch = plt$pch,\n                col = plt$col, bg = plt$bg, ... )\n      }\n\n    }\n\n    output = list(\n      pv = list( x = xv$P, y = yv$T_x ),\n      g = NULL,\n      i = list( rt = rt, ch = ch, cvrts = cvrts ),\n      opt = optOut\n    )\n  }\n\n  # If there is a grouping factor\n  if ( length( grp ) == length( rt ) ) {\n\n    # Apply the test statistic to response times\n    # over the covariate and grouping levels\n    yvAll = aggregate( rt, list( cvrts, grp ), T_x )\n    colnames( yvAll ) = c('Cv','G','T_x')\n\n    # Calculate the proportion of Y == ch over the\n    # covariate and grouping levels\n    xvAll = aggregate( ch, list( cvrts, grp ), mean )\n    colnames( xvAll ) = c('Cv','G','P')\n\n    # Aggregate over the grouping factor\n    yv = aggregate( yvAll$T_x, list( yvAll$Cv ), mean )\n    if ( dim( yv )[2] == 2 ) colnames( yv ) = c('Cv','T_x')\n    if ( dim( yv )[2] > 2 ) {\n      tmp = as.matrix( yv[,-1] )\n      yv = list( Cv = yv[,1], T_x = tmp )\n    }\n    xv = aggregate( xvAll$P, list( xvAll$Cv ), mean )\n    colnames( xv ) = c('Cv','P' )\n\n    # Determine the dimensions of the test statistic\n    dmn = dim( yv$T_x )\n\n    plt = pvt_plot_options(plt,dmn,xv)\n\n    if ( draw ) {\n\n      if ( length( dmn ) > 0 ) {\n        # If the y-axis values are in a matrix\n\n        # Plot the points for each level\n        for (i in 1:dmn[1]) {\n          points( rep( xv$P[i], dmn[2] ),\n                  yv$T_x[i,], pch = plt$pch[i,],\n                  col = plt$col[i,],\n                  bg = plt$bg[i,], ... )\n        }\n\n      } else {\n        # If the y-axis values are in a vector\n\n        # Plot the point for each level\n        points( xv$P, yv$T_x, pch = plt$pch,\n                col = plt$col, bg = plt$bg, ... )\n      }\n\n    }\n\n    output = list(\n      pv = list( x = xv$P, y = yv$T_x ),\n      g = list( w = yvAll, x = xvAll ),\n      i = list( rt = rt, ch = ch, cvrts = cvrts, grp = grp ),\n      opt = optOut\n    )\n\n  }\n\n  if (out) return( output )\n}\n\n# Lookup - 10\n#' Add uncertainty intervals to plot\n#'\n#' Adds uncertainty intervals (e.g. the mean +/- 1.96 standard errors)\n#' to a plot using output from other functions that were applied with\n#' a grouping factor.\n#'\n#' @param output the list output from functions like \\code{cdf_curve}\n#'   or \\code{quantile_points}.\n#' @param f an optional function to calculate the lower and upper boundaries\n#'   of an uncertainty interval given a coverage interval.\n#' @param alpha the desired coverage interval for the uncertainty interval.\n#' @param opt a list of named options:\n#'   \\describe{\n#'     \\item{\\code{draw}}{If true, the intervals are drawn.}\n#'     \\item{\\code{out}}{If true, output is returned.}\n#'   }\n#' @param ...  additional plotting parameters.\n#' @return A list consisting of...\n#' \\describe{\n#'   \\item{\\code{pv}}{a data frame with the plotting values\n#'     used for the x-axis and the y-axis.}\n#'   \\item{\\code{ui}}{a list giving the uncertainty intervals}\n#'   \\item{\\code{opt}}{a list of the options used.}\n#'   }\n#' @examples\n#' # Load in example dataset\n#' data(\"priming_data\")\n#' d = priming_data\n#' layout( cbind(1,2) )\n#' # Select condition\n#' cnd = d$Condition == 3\n#' rt = d$RT[cnd]; ch = d$Accuracy[cnd]; grp = d$Subject[cnd]\n#' # For curve functions\n#' blankRTplot()\n#' out = cdf_curve( rt, ch, grp = grp, opt = list( out = T, draw = F ) )\n#' add_uncertainty( out, border = NA, col = 'grey' )\n#' cdf_curve( rt, ch, grp = grp ) # Now draw the curve\n#' # For point functions (with new type of uncertainty interval)\n#' f = function(x,alpha) {\n#'   prb = c( (1-alpha)/2,alpha+(1-alpha)/2 );\n#'   quantile(x,prb)\n#' }\n#' blankRTplot()\n#' out = quantile_points( rt, ch, grp = grp, opt = list( draw = F, out = T ) )\n#' add_uncertainty( out, f = f, alpha = .5 )\n#' quantile_points( rt, ch, grp = grp, pch = 21, bg = 'grey' )\n#' @export\n\nadd_uncertainty = function( output, f = NULL, alpha = .95,\n                             opt = list( ), ... ) {\n\n  # Set options for drawing and output\n  if ( length( opt$draw ) == 0 ) draw = T else draw = opt$draw\n  if ( length( opt$out ) == 0 ) out = F else out = opt$out\n  # Save options\n  optOut = list( draw = draw, out = out )\n\n  # Extract choice to condition on\n  sel = output$v$sel\n  # Extract input\n  rt = output$i$rt; ch = output$i$ch\n  # Extract options on whether to flip\n  flip = output$opt$flip\n\n  # Determine if there is a grouping variable\n  grp = output$i$grp\n\n  # If no function is provided, define a uncertainty interval\n  # based on the mean and t-distribution\n  if ( length( f ) == 0 ) {\n\n    f = function(x,alpha) {\n      n = length(x)\n      se = sd(x)/sqrt( n )\n      crt = abs( qt( (1-alpha)/2, n - 1, lower.tail = T ) )\n      ui = c( mean(x) - crt*se, mean(x) + crt*se )\n      ui[ ui < 0 ] = 0\n\n      return(ui)\n    }\n\n  }\n\n  if ( length( grp ) == 0 ) stop('Need grouping factor')\n\n  # For 'pvt_point' functions\n  if ( is.data.frame( output$g$w ) ) {\n\n    yvAll = output$g$w\n    xvAll = output$g$x\n\n    yv = aggregate(yvAll$T_x,list(yvAll$Cv),f,alpha=.95)\n    xv = aggregate(xvAll$P,list(xvAll$Cv),f,alpha=.95)\n    dmn = dim( yv )\n    if (draw) {\n\n      for ( i in 2:dmn[2] ) {\n        for ( j in 1:dmn[1] ) {\n\n          addEllipse( diff( xv[[2]][j,] ),\n                      diff( yv[[i]][j,] ),\n                      output$pv$x[j],\n                      output$pv$y[j,i-1], ... )\n        }\n      }\n\n    }\n\n    # Save output\n    newOutput = list(\n      pv = cbind( x = xv$x, y = yv[,2:dmn[2]] ),\n      ui = list( x = xv, y = yv ),\n      opt = opt )\n\n    if (out) return( newOutput ) else return()\n  }\n\n  # For curve functions\n  if ( !is.matrix( output$g$x ) ) {\n\n    # Calculate uncertainty interval for y-axis values\n    ui = apply( output$g$w, 2, f, alpha = alpha )\n    x = output$g$x\n\n    # Plot uncertainty interval\n    xa = c( x, rev(x) )\n    ya = c( ui[1,], rev( ui[2,] ) )\n    if (flip) ya = -ya\n\n    if (draw) {\n\n      polygon( xa, ya, ... )\n\n    }\n\n    # Save output\n    newOutput = list(\n      pv = cbind( x = xa, y = ya ),\n      ui = list( y = ui ),\n      opt = opt )\n\n  }\n\n  # For point functions\n  if ( is.matrix( output$g$x ) ) {\n\n    # Extract centering info\n    xc = output$pv[,'x']\n    yc = output$pv[,'y']\n    # Compute uncertainty variables for both x and y-axis\n    ya = apply( output$g$w, 2, f, alpha = alpha )\n    xa = apply( output$g$x, 2, f, alpha = alpha )\n\n    # Plot intervals\n    if ( draw ) {\n      segments( xa[1,], yc, xa[2,], yc, ... )\n      segments( xc, ya[1,], xc, ya[2,], ... )\n    }\n\n    # Save output\n    newOutput = list(\n      pv = cbind( x1 = xa[1,], x2 = xa[2,],\n                  y1 = ya[1,], y2 = ya[2,],\n                  xc = xc, yc = yc ),\n      ui = list( x = xa, y = ya ),\n      opt = opt )\n\n  }\n\n  if (out ) return( newOutput )\n}\n",
    "created" : 1470865420129.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1633669559",
    "id" : "1EE66D6D",
    "lastKnownWriteTime" : 1478741358,
    "path" : "F:/Stuff/Kevin's Stuff/Postdoc/R packages/rtplots/R/rt_plot_functions.R",
    "project_path" : "R/rt_plot_functions.R",
    "properties" : {
        "tempName" : "Untitled2"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "type" : "r_source"
}