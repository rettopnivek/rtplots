{
    "collab_server" : "",
    "contents" : "#---------------#\n# PvT functions #\n#---------------#\n\n# * Incomplete documentation\n\n# Index\n# Lookup - 01:  pvt_one_level*\n# Lookup - 02:  pvt_multi_levels*\n# Lookup - 03:  create_pvt_output\n# Lookup - 04:  check_for_pvt_type\n# Lookup - 05:  pvt_default_options*\n\n# Lookup - 01\npvt_one_level = function( input, npfd, f = NULL ) {\n  # Purpose:\n  # ...\n  # Arguments:\n  # input - ?\n  # npfd  - ?\n  # f     - ?\n  # Returns:\n  # ...\n\n  # If no function for the test statistic is provided\n  # use mean as default\n  if ( is.null( f ) ) f = mean\n\n  # Create output dataframe\n  l = nrow( npfd ); n_v = input$n_v\n  pd = data.frame( x = as.vector( npfd$P ),\n                   v = rep( input$val, each = l ),\n                   cv = rep( npfd$CV, n_v ) )\n\n  inc = 1\n  vrb = rep( ' ', nrow(pd) )\n  for ( vl in input$val ) {\n    sel = input$ad$v == vl\n    if ( sum( sel ) > 0 ) {\n\n      tmp = by( input$ad$t[sel], list( input$ad$cv[sel] ), f )\n      if ( inc == 1 ) mat =  matrix( NA, nrow( pd ), length(tmp[[1]]) )\n\n      sel = pd$v == vl & pd$cv %in% names( tmp )\n      vrb[sel] = names( tmp )\n      mat[sel,]  = matrix( unlist( tmp ), length( tmp ), length(tmp[[1]]),\n                    byrow = T )\n      inc = inc + 1\n    }\n  }\n  if ( exists( 'mat' ) ) pd$y = mat\n\n  out = list( pd = pd, xm = NULL, ym = NULL )\n\n  return( out )\n}\n\n\n# Lookup - 02\npvt_multi_levels = function( input, npfd, f = NULL, T_x = NULL ) {\n  # Purpose:\n  # ...\n  # Arguments:\n  # input\n  # npfd\n  # T_x\n  # Returns:\n  # ...\n\n  if ( is.null(f) ) f = mean\n  if ( is.null(T_x) ) T_x = function(x) mean(x,na.rm = T)\n\n  n_v = input$n_v; n_cv = input$n_cv; l = n_v * n_cv\n  pd = data.frame( x = rep( NA, l ),\n                   v = rep( input$val, each = n_cv ),\n                   cv = rep( unique( npfd$CV ), n_v ) )\n\n  n_t = length( f( input$ad$t ) )\n\n  xm = matrix( NA, input$n_g, nrow( pd ) )\n  ym = array( NA, dim = c( input$n_g, nrow( pd ), n_t ) )\n\n  for ( g in 1:input$n_g ) {\n\n    sel_1 = input$ad$g == input$g_v[g]\n    sel_2 = npfd$G == input$g_v[g]\n\n    inc = 1\n    vrb = rep( ' ', nrow(pd) )\n    for ( vl in input$val ) {\n      sel = input$ad$v == vl\n      if ( sum( sel ) > 0 ) {\n\n        tmp = by( input$ad$t[sel_1 & sel], list( input$ad$cv[sel_1 & sel] ), f )\n        if ( inc == 1 ) mat =  matrix( NA, nrow( pd ), length(tmp[[1]]) )\n\n        sel = pd$v == vl & pd$cv %in% names( tmp )\n        vrb[sel] = names( tmp )\n        mat[sel,]  = matrix( unlist( tmp ), length( tmp ), length(tmp[[1]]),\n                             byrow = T )\n        inc = inc + 1\n      }\n    }\n    if ( exists( 'mat' ) ) ym[g,,] = mat\n    xm[g,] = as.vector( npfd$P[sel_2,] )\n\n  }\n\n  pd$x = apply( xm, 2, T_x )\n  pd$y = apply( ym, 2:3, T_x )\n\n  out = list( pd = pd, xm = xm, ym = ym )\n\n  return( out )\n}\n\n# Lookup - 03\ncreate_pvt_output = function( input, npfd, ... ) {\n  # Purpose:\n  # Computes the ? function based on the number\n  # grouping factor levels\n  # Arguments:\n  # input - The output from the 'extract_var' function\n  #         (defined in 'utility.R')\n  # npfd  - The output from the 'extract_npfd' function\n  #         (defined in 'gen_dist_char.R')\n  # ...   - Optional variables for the pvt functions\n  # Returns:\n  # The list of plotting elements.\n\n  plt = NULL\n  if ( input$n_g == 1 ) plt = pvt_one_level( input, npfd, ... )\n  if ( input$n_g > 1 ) plt = pvt_multi_levels( input, npfd, ... )\n\n  return( plt )\n}\n\n# Lookup - 04\ncheck_for_pvt_type = function( type ) {\n  # Purpose:\n  # Checks a string character against a list of\n  # possible labels for selecting the PvT option.\n  # Arguments:\n  # type = The input string\n  # Returns:\n  # A logical value, equal to 'TRUE' if one of the\n  # labels matches the input string.\n\n  pvt_types = c( 'PVT', 'pvt', 'PvT', 'pVT', 'PVt',\n                 'pvT', 'pVt', 'Pvt' )\n\n  return( type %in% pvt_types )\n}\n\n# Lookup - 05\npvt_default_options = function( opt, pd, ver ) {\n  # Purpose:\n  #\n  # Arguments:\n  # opt -\n  # pd  -\n  # ver -\n  # Returns:\n  #\n\n  R = nrow( pd )\n  C = ncol( pd$y )\n\n  if ( is.null(opt) ) {\n\n    if ( ver == 'pch' ) {\n\n      if ( length( unique( pd$cv ) ) <= 9 ) {\n        inc = 1\n        lev = rep( \" \", nrow( pd ) )\n        for ( u in unique( pd$cv ) ) {\n          lev[ u == pd$cv ] = as.character( inc )\n          inc = inc + 1\n        }\n        out = matrix( lev, R, C )\n      } else {\n        out = matrix( 19, R, C )\n      }\n    }\n\n    if ( ver == 'cex' ) {\n      out = matrix( 1, R, C )\n    }\n\n    if ( ver == 'col' ) {\n      out = matrix( 'black', R, C )\n    }\n\n    if ( ver == 'bg' ) {\n      out = matrix( 'black', R, C )\n    }\n\n    if ( ver == 'lty' ) {\n      out = matrix( 1, R, C )\n    }\n\n    if ( ver == 'lwd' ) {\n      out = matrix( 1, R, C )\n    }\n\n  } else out = opt\n\n  return( out )\n}\n",
    "created" : 1505849700607.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3133859365",
    "id" : "E0B6483C",
    "lastKnownWriteTime" : 1506633136,
    "last_content_update" : 1506633134389,
    "path" : "F:/Stuff/Kevin's Stuff/Postdoc/R packages/rtplots/R/pvt_functions.R",
    "project_path" : "R/pvt_functions.R",
    "properties" : {
        "tempName" : "Untitled2"
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}