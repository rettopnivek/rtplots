{
    "collab_server" : "",
    "contents" : "#----------------------------------#\n# Functions for plotting data from #\n# simple choice and response time  #\n# tasks                            #\n#----------------------------------#\n\n# Useful functions for package creation\n# library(devtools)\n# library(roxygen2)\n\n# Index\n# Lookup - 01:  rtplots\n# Lookup - 02:  is.rtplots\n# Lookup - 03:  lines.rtplots\n# Lookup - 04:  points.rtplots\n# Lookup - 05:  plot.rtplots\n\n# Lookup - 01\n#' Creates a 'rtplots' Object\n#'\n#' Creates a 'rtplots' object from a data frame of\n#' response time and choice/accuracy data, allowing\n#' for subsequent plotting.\n#'\n#' @param df a data frame that includes (at a minimum) a column of\n#'   response times.\n#' @param label a character string giving the column name for\n#'   the respons time variable, and optionally the choice/accuracy\n#'   variable and a grouping factor variable (e.g., subjects).\n#'   If \\code{NULL}, the algorithm will attempt to locate response\n#'   time and choice/accuracy variables via a set of default names.\n#' @param keep a logical vector, indicating which rows should be\n#'   kept when extracting the variables.\n#' @param type the type of function to compute. Options are\n#'   \\itemize{\n#'     \\item \\code{CDF}; the cumulative distribution function.\n#'     \\item \\code{QPE}; the quantile function.\n#'   }\n#' @param level an optional index indicating the specific level\n#'   of the grouping factor to consider. This allows, for instance,\n#'   selecting a single subject.\n#' @param ... additional parameters for the density, distribution,\n#'   and quantile functions.\n#'\n#' @details\n#'\n#' Forthcoming\n#'\n#' @return An object of class 'rtplots', a list consisting of...\n#'   \\itemize{\n#'     \\item \\code{pd}; a data frame with the x and y values\n#'       to plot and their associated choice/accuracy value.\n#'     \\item \\code{xm}; If relevant, a matrix whose columns\n#'       contain the individual x-axis values of the function\n#'       which were collapsed over the grouping factor.\n#'     \\item \\code{ym}; If relevant, a matrix whose columns\n#'       contain the individual y-axis values of the function\n#'       which were collapsed over the grouping factor.\n#'     \\item \\code{npfd}; a data frame with the number of\n#'       observations, proportions, and frequencies based on\n#'       the choice/accuracy values.\n#'     \\item \\code{type}; the type of function that was applied.\n#'     \\item \\code{x}; the range of x-axis values.\n#'     \\item \\code{y}; the range of y-axis values.\n#'   }\n#'\n#' @references\n#'\n#' Forthcoming\n#'\n#' @examples\n#' # Load in example dataset\n#' data(\"priming_data\")\n#' lbl = c( 'RT', 'Accuracy', 'Subjects' )\n#' keep = priming_data$Condition == 0\n#' obj = rtplots( priming_data, label = lbl, keep = keep )\n#'\n#' @export\nrtplots = function( df, label = NULL, keep = NULL,\n                    type = 'CDF', level = NULL, ... ) {\n\n  # Check input\n  if ( !is.data.frame( df ) )\n    stop( 'Input variable must be a data frame' )\n\n  output = extract_var( df, label, keep )\n  output = sort_input( output, level )\n  npfd = extract_npfd( output )\n\n  ### Empirical cumulative distribution function ###\n\n  if ( check_for_cdf_type(type) ) {\n    tmp = create_cdf_output( output, npfd, ... )\n    output$pd = tmp$pd\n    output$xm = tmp$xm\n    output$ym = tmp$ym\n    output$npfd = npfd\n    output$type = 'CDF'\n  } else if ( check_for_qpe_type(type) ) {\n    tmp = create_qpe_output( output, npfd, ... )\n    output$pd = tmp$pd\n    output$xm = tmp$xm\n    output$ym = tmp$ym\n    output$npfd = npfd\n    output$type = 'QPE'\n  } else {\n    err = 'That function type is unknown.'\n    stop( err, call. = FALSE )\n  }\n\n  # Plotting range\n  output$x = range( na.omit( output$pd$x ) )\n  output$y = range( output$pd$y )\n\n  class( output ) = 'rtplots'\n\n  return( output )\n}\n\n# Lookup - 02\n#' @rdname rtplots\n#' @export\nis.rtplots = function(x) inherits(x, \"rtplots\")\n\n# Lookup - 03\n#' Lines Method for 'rtplots' Object\n#'\n#' Provides a method to 'rtplots' objects that allows\n#' for drawing line segments on an existing plot.\n#'\n#' @param object a 'rtplots' object.\n#' @param val the choice or accuracy value whose observations\n#'   are to be plotted.\n#' @param ind a index to select observations for a specific\n#'   choice/accuracy value.\n#' @param flip logical; if true, flips the y-axis values to\n#'   be negative.\n#' @param ... additional plotting parameters. See\n#'   \\code{\\link[graphics]{lines}}.\n#'\n#' @export\nlines.rtplots = function( object, val = NULL,\n                          ind = 1, flip = F, ... ) {\n\n  if ( !is.null( val ) ) {\n    vl = val == object$pd$v\n  } else {\n    vl = object$val[ ind ] == object$pd$v\n  }\n\n  if ( !flip ) {\n    lines( object$pd$x[vl], object$pd$y[vl], ... )\n  } else {\n    lines( object$pd$x[vl], -object$pd$y[vl], ... )\n  }\n\n}\n\n# Lookup - 04\n#' Points Method for 'rtplots' Object\n#'\n#' Provides a method to 'rtplots' objects that allows\n#' for drawing points on an existing plot.\n#'\n#' @param object a 'rtplots' object.\n#' @param val the choice or accuracy value whose observations\n#'   are to be plotted.\n#' @param ind a index to select observations for a specific\n#'   choice/accuracy value.\n#' @param flip logical; if true, flips the y-axis values to\n#'   be negative.\n#' @param ... additional plotting parameters. See\n#'   \\code{\\link[graphics]{points}}.\n#'\n#' @export\npoints.rtplots = function( object, val = NULL,\n                           ind = 1, flip = F, ... ) {\n\n  if ( !is.null( val ) ) {\n    vl = val == object$pd$v\n  } else {\n    vl = object$val[ ind ] == object$pd$v\n  }\n\n  if ( !flip ) {\n    points( object$pd$x[vl], object$pd$y[vl], ... )\n  } else {\n    points( object$pd$x[vl], -object$pd$y[vl], ... )\n  }\n\n}\n\n# Lookup - 05\n#' Plot Method for 'rtplots' Object\n#'\n#' Creates a blank plot based on a 'rtplots' object.\n#'\n#' @param x a 'rtplots' object.\n#' @param y the y-axis boundaries.\n#' @param inc the interval for the ticks on the\n#'   x and y-axes (depending on the plot).\n#' @param type if eqaul to \\code{'blank'}, a completely\n#'   blank plot is generated. Otherwise, converted to \\code{'n'}.\n#' @param xlab a character string for the label on the x-axis.\n#' @param ylab a character string for the label on the y-axis.\n#' @param bty the type of box to draw around the plot. See\n#'   \\code{\\link[graphics]{par}}.\n#' @param ... additional plotting parameters. See\n#'   \\code{\\link[graphics]{par}}.\n#'\n#' @export\nplot.rtplots = function( x,\n                         y = NULL,\n                         inc = NULL,\n                         type = NULL,\n                         xlab = NULL,\n                         ylab = NULL,\n                         bty = NULL, ... ) {\n\n  # Extract 'rtplots' object\n  object = x\n\n  if ( object$type == 'CDF' ) {\n\n    # Determine x and y-axis boundaries\n    if ( is.null( inc ) ) inc = .2\n    xl = lower_upper( inc[1], object$pd$x )\n    if ( is.null( y ) ) yl = c(0,1) else yl = y\n\n    # Default options for plot\n    if ( is.null( xlab ) ) xlb = 'Time' else xlb = xlab\n    if ( is.null( ylab ) ) ylb = 'Distribution function'\n    else ylb = ylab\n    if ( is.null( bty ) ) bx = 'l' else bx = bty\n\n    plotYes = T\n\n    # Plot type\n    if ( !is.null( type ) ) {\n\n      if ( type == 'blank' | type == 'Blank' ) {\n        plot( xl, yl, type = 'n', xlab = ' ',\n              ylab = ' ', xaxt = 'n', yaxt = 'n',\n              bty = 'n' )\n      }\n\n      plotYes = F\n\n    } else type = 'n'\n\n    if ( plotYes )\n      plot( xl, yl, type = type, xlab = xlb, ylab = ylb,\n            bty = bx, ... )\n\n  }\n\n  if ( object$type == 'QPE' ) {\n\n    # Determine x and y-axis boundaries\n    if ( is.null( inc ) ) inc = .2\n    xl = lower_upper( inc, na.omit( object$pd$x ) )\n    if ( is.null( y ) ) yl = c(0,1) else yl = y\n\n    # Default options for plot\n    if ( is.null( xlab ) ) xlb = 'Time' else xlb = xlab\n    if ( is.null( ylab ) ) ylb = 'Quantile function'\n    else ylb = ylab\n    if ( is.null( bty ) ) bx = 'l' else bx = bty\n\n    plotYes = T\n\n    # Plot type\n    if ( !is.null( type ) ) {\n\n      if ( type == 'blank' | type == 'Blank' ) {\n        plot( xl, yl, type = 'n', xlab = ' ',\n              ylab = ' ', xaxt = 'n', yaxt = 'n',\n              bty = 'n' )\n      }\n\n      plotYes = F\n\n    } else type = 'n'\n\n    if ( plotYes )\n      plot( xl, yl, type = type, xlab = xlb, ylab = ylb,\n            bty = bx, ... )\n\n  }\n\n}\n\n# Lookup - 06\n#' Computes Uncertainty Intervals for 'rtplots' Objects\n#'\n#' A function that computes a specified uncertainty\n#' interval (such as \\eqn{\\pm} 2 standard errors from\n#' the mean) for a 'rtplots' object.\n#'\n#' @param object a 'rtplots' object.\n#' @param f a function to compute the boundaries of\n#'   the uncertainty interval given the desired\n#'   range of coverage (takes at least two parameters,\n#'   a vector \\code{x} and a range \\code{interval}).\n#' @param alpha the desired width of coverate for the\n#'   given uncertainty interval.\n#' @param ... additional parameters for the\n#'   function \\code{f}.\n#'\n#' @return Forthcoming\n#'\n#' @export\nuncertainty = function( object, f = NULL,\n                        alpha = .95, ... ) {\n\n  # If no function is provided, assume uncertainty\n  # intervals should be calculated using the\n  # standard error of the mean\n  if ( is.null( f ) ) {\n    f = function(x,interval) {\n      s = sd( x )/sqrt( length(x) ) # Standard error\n      m = mean(x)\n      return( c( m - abs( qnorm(interval[1]) )*s,\n                 m + abs( qnorm(interval[2] ) )*s ) )\n    }\n  }\n\n  # Determine lower and upper boundaries\n  interval = numeric(2);\n  interval[1] = (1 - alpha)/2\n  interval[2] = interval[1] + alpha\n\n  # Initialize output\n  ud = NULL\n  pd = NULL\n\n  # If there is more than one group\n  if ( object$n_g > 1 ) {\n\n    l = nrow( object$pd )\n\n    ud = data.frame( x = rep( NA, l * 3 ),\n                     y = rep( NA, l * 3 ),\n                     loc = rep( NA, l * 3 ),\n                     v = rep( NA, l * 3 ),\n                     i = rep( NA, l * 3 ) )\n\n    # Loop over choice/accuracy values\n    sta = 1; end = 0\n    for ( i in 1:(object$n_v) ) {\n\n      # Compute uncertainty intervals\n      if ( !is.null( object$xm ) ) {\n        xui = apply( object$xm[[i]], 2, f, interval = interval,\n                     ... )\n      } else xui = NULL\n      if ( !is.null( object$ym ) ) {\n        yui = apply( object$ym[[i]], 2, f, interval = interval,\n                     ... )\n      } else yui = NULL\n\n      sel = object$val[ i ] == object$pd$v\n\n      # Center values\n      end = end + sum( sel )\n      ud$x[ sta:end ] = object$pd$x[ sel ]\n      ud$y[ sta:end ] = object$pd$y[ sel ]\n      ud$v[ sta:end ] = object$pd$v[ sel ]\n      ud$loc[ sta:end ] = 'center'\n      ud$i[ sta:end ] = 1:sum(sel)\n      sta = end + 1\n\n      # Lower boundary\n      end = end + sum( sel )\n      if ( is.null( xui ) )\n        ud$x[ sta:end ] = object$pd$x[ sel ] else\n          ud$x[ sta:end ] = xui[1,]\n      if ( is.null( yui ) )\n        ud$y[ sta:end ] = object$pd$y[ sel ] else\n          ud$y[ sta:end ] = yui[1,]\n      ud$v[ sta:end ] = object$pd$v[ sel ]\n      ud$loc[ sta:end ] = 'lower'\n      sta = end + 1\n\n      # Upper boundary\n      end = end + sum( sel )\n      if ( is.null( xui ) )\n        ud$x[ sta:end ] = object$pd$x[ sel ] else\n          ud$x[ sta:end ] = xui[2,]\n      if ( is.null( yui ) )\n        ud$y[ sta:end ] = object$pd$y[ sel ] else\n          ud$y[ sta:end ] = yui[2,]\n      ud$v[ sta:end ] = object$pd$v[ sel ]\n      ud$loc[ sta:end ] = 'upper'\n      sta = end + 1\n\n    }\n\n    pd = data.frame( xl = rep( NA, l * 2 ),\n                     xu = rep( NA, l * 2 ),\n                     yl = rep( NA, l * 2 ),\n                     yu = rep( NA, l * 2 ) )\n    pd$xl = c( ud$x[ ud$loc == 'lower' ],\n               ud$x[ ud$loc == 'center' ] )\n    pd$xu = c( ud$x[ ud$loc == 'upper' ],\n               ud$x[ ud$loc == 'center' ] )\n    pd$yl = c( ud$y[ ud$loc == 'center' ],\n               ud$y[ ud$loc == 'lower' ] )\n    pd$yu = c( ud$y[ ud$loc == 'center' ],\n               ud$y[ ud$loc == 'upper' ] )\n    pd$v = rep( ud$v[ ud$loc == 'center' ], 2 )\n    pd$i = rep( ud$i[ ud$loc == 'center' ], 2 )\n\n  }\n\n  out = list(\n    pd = pd,\n    ud = ud,\n    xm = object$xm,\n    ym = object$ym,\n    val = object$val\n  )\n\n  # Define new class\n  class( out ) = 'rtplots_ui';\n\n  return( out )\n}\n\n# Lookup - 07\n#' Draw Uncertainty Intervals\n#'\n#' A convenience function that draws uncertainty\n#' intervals computed from a 'rtplots' object onto\n#' an already existing plot.\n#'\n#' @param ui a 'rtplots_ui' object.\n#' @param val the choice/accuracy value for which to\n#'   draw the uncertainty intervals.\n#' @param ind the index of the desired choice/accuracy\n#'   value over which to draw uncertainty intervals.\n#' @param flip logical; if \\code{true} the y-axis\n#'   values are flipped to be negative.\n#' @param type the type of method used to draw the\n#'   uncertainty interval. Options are\n#'   \\itemize{\n#'     \\item \\code{segments}.\n#'     \\item \\code{arrows}.\n#'     \\item \\code{polygon}.\n#'   }\n#' @param ... additional plotting parameters. See\n#'   \\code{\\link[graphics]{segments}},\n#'   \\code{\\link[graphics]{arrows}}, and\n#'   \\code{\\link[graphics]{polygon}}.\n#'\n#' @export\ndraw_ui = function( ui, val = NULL, ind = 1,\n                    flip = F, type = 'segments', ... ) {\n\n  if ( !is.null( val ) ) {\n    vl = val == ui$pd$v\n  } else {\n    vl = ui$val[ ind ] == ui$pd$v\n  }\n  if (!flip) w = 1 else w = -1\n\n  segment_names = c( 'segments', 's', 'seg' )\n  if ( type %in% segment_names ) {\n    segments( ui$pd$xl[vl], w*ui$pd$yl[vl],\n              ui$pd$xu[vl], w*ui$pd$yu[vl], ... )\n  }\n\n  polygon_names = c( 'polygon', 'p', 'poly' )\n  if ( type %in% polygon_names ) {\n\n    polygon( c( ui$pd$xl[vl], rev( ui$pd$xu[vl] ) ),\n             c( ui$pd$yu[vl], rev( ui$pd$yl[vl] ) ),\n             ... )\n  }\n\n  arrow_names = c( 'arrows', 'a', 'arr' )\n  if ( type %in% arrow_names ) {\n    arrows( ui$pd$xl[vl], w*ui$pd$yl[vl],\n            ui$pd$xu[vl], w*ui$pd$yu[vl], ... )\n  }\n\n}\n",
    "created" : 1495914176960.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1636447440",
    "id" : "FFBD1CB9",
    "lastKnownWriteTime" : 1498240184,
    "last_content_update" : 1498240183461,
    "path" : "F:/Stuff/Kevin's Stuff/Postdoc/R packages/rtplots/R/plotting_functions.R",
    "project_path" : "R/plotting_functions.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}