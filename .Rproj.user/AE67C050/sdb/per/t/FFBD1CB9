{
    "collab_server" : "",
    "contents" : "#----------------------------------#\n# Functions for plotting data from #\n# simple choice and response time  #\n# tasks                            #\n#----------------------------------#\n\n# Useful functions for package creation\n# library(devtools)\n# library(roxygen2)\n\n# * Incomplete documentation\n\n# Index\n# Lookup - 01:  rtplots*\n# Lookup - 02:  is.rtplots\n# Lookup - 03:  lines.rtplots\n# Lookup - 04:  points.rtplots\n# Lookup - 05:  plot.rtplots\n# Lookup - 06:  uncertainty*\n# Lookup - 07:  draw_ui\n# Lookup - 08:  add_to_rtplot*\n# Lookup - 09\n\n# Lookup - 01\n#' Creates a 'rtplots' Object\n#'\n#' Creates a 'rtplots' object from a data frame of\n#' response time and choice/accuracy data, allowing\n#' for subsequent plotting.\n#'\n#' @param df a data frame that includes (at a minimum) a column of\n#'   response times.\n#' @param label a character string giving the column name for\n#'   the response time variable, and optionally the choice/accuracy\n#'   variable, a grouping factor variable (e.g., subjects), and\n#'   finally an additional covariate (e.g., conditions). If\n#'   \\code{NULL}, the algorithm will attempt to locate response\n#'   time and choice/accuracy variables via a set of default names.\n#' @param keep a logical vector, indicating which rows should be\n#'   kept when extracting the variables.\n#' @param type the type of function to compute. Options are\n#'   \\itemize{\n#'     \\item \\code{CDF}: the cumulative distribution function.\n#'     \\item \\code{QPE}: the quantile function.\n#'     \\item \\code{PDF}: the probability density function.\n#'     \\item \\code{PVT}: probability versus time.\n#'   }\n#' @param level an optional index indicating the specific level\n#'   of the grouping factor to consider. This allows, for instance,\n#'   selecting a single subject.\n#' @param ... additional parameters for the density, distribution,\n#'   and quantile functions.\n#'\n#' @details\n#'\n#' Forthcoming\n#'\n#' @return An object of class 'rtplots', a list consisting of...\n#'   \\itemize{\n#'     \\item \\code{pd}; a data frame with the x and y values\n#'       to plot and their associated choice/accuracy value.\n#'     \\item \\code{xm}; If relevant, a matrix whose columns\n#'       contain the individual x-axis values of the function\n#'       which were collapsed over the grouping factor.\n#'     \\item \\code{ym}; If relevant, a matrix whose columns\n#'       contain the individual y-axis values of the function\n#'       which were collapsed over the grouping factor.\n#'     \\item \\code{npfd}; a data frame with the number of\n#'       observations, proportions, and frequencies based on\n#'       the choice/accuracy values.\n#'     \\item \\code{type}; the type of function that was applied.\n#'     \\item \\code{x}; the range of x-axis values.\n#'     \\item \\code{y}; the range of y-axis values.\n#'   }\n#'\n#' @references\n#'\n#' Forthcoming\n#'\n#' @examples\n#' # Load in example dataset\n#' data(\"priming_data\")\n#' lbl = c( 'RT', 'Accuracy', 'Subjects' )\n#' keep = priming_data$Condition == 0\n#' obj = rtplots( priming_data, label = lbl, keep = keep )\n#'\n#' @export\nrtplots = function( df, label = NULL, keep = NULL,\n                    type = 'CDF', level = NULL, ... ) {\n\n  # Check input\n  if ( !is.data.frame( df ) )\n    stop( 'Input variable must be a data frame' )\n\n  output = extract_var( df, label, keep, type )\n  # Sort RTs into ascending order\n  output = sort_input( output, level )\n  # Compute proportions and frequencies\n  npfd = extract_npfd( output )\n\n  if ( check_for_cdf_type(type) ) {\n    ### CDF\n\n    # Generate output\n    tmp = create_cdf_output( output, npfd, ... )\n    output$pd = tmp$pd\n    output$xm = tmp$xm\n    output$ym = tmp$ym\n    output$npfd = npfd\n    output$type = 'CDF'\n\n  } else if ( check_for_qpe_type(type) ) {\n    ### QPE\n\n    # Generate output\n    tmp = create_qpe_output( output, npfd, ... )\n    output$pd = tmp$pd\n    output$xm = tmp$xm\n    output$ym = tmp$ym\n    output$npfd = npfd\n    output$type = 'QPE'\n\n  } else if ( check_for_pdf_type(type) ) {\n    ### PDF\n\n    # Generate output\n    tmp = create_pdf_output( output, npfd, ... )\n    output$pd = tmp$pd\n    output$xm = tmp$xm\n    output$ym = tmp$ym\n    output$npfd = npfd\n    output$type = 'PDF'\n  } else if ( check_for_pvt_type(type) ) {\n    ### PVT\n\n    # Generate output\n    tmp = create_pvt_output( output, npfd, ... )\n    output$pd = tmp$pd\n    output$xm = tmp$xm\n    output$ym = tmp$ym\n    output$npfd = npfd\n    output$type = 'PVT'\n  } else {\n    err = 'That function type is unknown.'\n    stop( err, call. = FALSE )\n  }\n\n  # Plotting range\n  output$x = range( na.omit( output$pd$x ) )\n  output$y = range( output$pd$y )\n\n  class( output ) = 'rtplots'\n\n  return( output )\n}\n\n# Lookup - 02\n#' @rdname rtplots\n#' @export\nis.rtplots = function(x) inherits(x, \"rtplots\")\n\n# Lookup - 03\n#' Lines Method for 'rtplots' Object\n#'\n#' Provides a method to 'rtplots' objects that allows\n#' for drawing line segments on an existing plot.\n#'\n#' @param object a 'rtplots' object.\n#' @param val the choice or accuracy value whose observations\n#'   are to be plotted.\n#' @param ind a index to select observations for a specific\n#'   choice/accuracy value.\n#' @param flip logical; if true, flips the y-axis values to\n#'   be negative.\n#' @param ... additional plotting parameters. See\n#'   \\code{\\link[graphics]{lines}}.\n#'\n#' @export\nlines.rtplots = function( object, val = NULL,\n                          ind = 1, flip = F, ... ) {\n\n  # If it isn't a probability versus time plot\n  if ( object$type != 'PVT' ) {\n\n    if ( !is.null( val ) ) {\n      vl = val == object$pd$v\n    } else {\n      vl = object$val[ ind ] == object$pd$v\n    }\n\n    if ( !flip ) {\n      lines( object$pd$x[vl], object$pd$y[vl], ... )\n    } else {\n      lines( object$pd$x[vl], -object$pd$y[vl], ... )\n    }\n  } else { # Special options for PvT figures\n\n    # Extract choice value\n    if ( is.null( val ) ) val = object$val[ ind ]\n\n    # Check for multiple RTs per probability\n    dmn = dim( object$pd$y )\n\n    # If the points aren't flipped about the x-axis\n    if ( !flip ) {\n\n      # Subset of values matching desired choice value\n      vl = which( object$pd$v %in% val )\n\n      for ( i in 1:dmn[2] ) {\n        x = object$pd$x[vl]\n        y = object$pd$y[vl,i]\n        ord = order(x)\n        lines( x[ord], y[ord], ... )\n      }\n\n    } else { # Flip\n\n      # Subset of values matching desired choice value\n      vl = which( object$pd$v %in% val )\n\n      for ( i in 1:dmn[2] ) {\n        x = object$pd$x[vl]\n        y = object$pd$y[vl,i]\n        ord = order(x)\n        lines( x[ord], -y[ord], ... )\n      }\n\n    }\n  }\n}\n\n# Lookup - 04\n#' Points Method for 'rtplots' Object\n#'\n#' Provides a method to 'rtplots' objects that allows\n#' for drawing points on an existing plot.\n#'\n#' @param object a 'rtplots' object.\n#' @param val the choice or accuracy value whose observations\n#'   are to be plotted.\n#' @param ind a index to select observations for a specific\n#'   choice/accuracy value.\n#' @param flip logical; if true, flips the y-axis values to\n#'   be negative.\n#' @param ... additional plotting parameters. See\n#'   \\code{\\link[graphics]{points}}.\n#'\n#' @export\npoints.rtplots = function( object, val = NULL,\n                           ind = 1, flip = F, ... ) {\n\n  # If it isn't a probability versus time plot\n  if ( object$type != 'PVT' ) {\n\n    # If a choice value is given\n    if ( !is.null( val ) ) {\n      vl = val == object$pd$v\n    } else {\n      vl = object$val[ ind ] == object$pd$v\n    }\n\n    # If the points aren't flipped about the x-axis\n    if ( !flip ) {\n      points( object$pd$x[vl], object$pd$y[vl], ... )\n    } else { # Flip\n      points( object$pd$x[vl], -object$pd$y[vl], ... )\n    }\n\n  } else { # Special options for PvT figures\n\n    # Extract choice value\n    if ( is.null( val ) ) val = object$val[ ind ]\n\n    # Check for multiple RTs per probability\n    dmn = dim( object$pd$y )\n\n    # If the points aren't flipped about the x-axis\n    if ( !flip ) {\n\n      # Subset of values matching desired choice value\n      vl = which( object$pd$v %in% val )\n\n      for ( i in 1:length(vl) ) {\n        x = rep( object$pd$x[vl[i]], dmn[2] )\n        y = object$pd$y[vl[i],]\n        points( x, y, ... )\n      }\n\n    } else { # Flip\n\n      # Subset of values matching desired choice value\n      vl = which( object$pd$v %in% val )\n\n      for ( i in 1:length(vl) ) {\n        x = rep( object$pd$x[vl[i]], dmn[2] )\n        y = object$pd$y[vl[i],]\n        points( x, -y, ... )\n      }\n\n    }\n  }\n}\n\n# Lookup - 05\n#' Plot Method for 'rtplots' Object\n#'\n#' Creates a blank plot based on a 'rtplots' object.\n#'\n#' @param x a 'rtplots' object.\n#' @param y the y-axis boundaries.\n#' @param inc the interval for the ticks on the\n#'   x and y-axes (depending on the plot).\n#' @param type if equal to \\code{'blank'}, a completely\n#'   blank plot is generated. Otherwise, converted to \\code{'n'}.\n#' @param xlab a character string for the label on the x-axis.\n#' @param ylab a character string for the label on the y-axis.\n#' @param bty the type of box to draw around the plot. See\n#'   \\code{\\link[graphics]{par}}.\n#' @param ... additional plotting parameters. See\n#'   \\code{\\link[graphics]{par}}.\n#'\n#' @export\nplot.rtplots = function( x,\n                         y = NULL,\n                         inc = NULL,\n                         type = NULL,\n                         xlab = NULL,\n                         ylab = NULL,\n                         bty = NULL, ... ) {\n\n  # Extract 'rtplots' object\n  object = x\n\n  if ( object$type == 'CDF' ) {\n\n    # Determine x and y-axis boundaries\n    if ( is.null( inc ) ) inc = .2\n    xl = lower_upper( inc[1], object$pd$x )\n    if ( is.null( y ) ) yl = c(0,1) else yl = y\n\n    # Default options for plot\n    if ( is.null( xlab ) ) xlb = 'Time' else xlb = xlab\n    if ( is.null( ylab ) ) ylb = 'Distribution function'\n    else ylb = ylab\n    if ( is.null( bty ) ) bx = 'l' else bx = bty\n\n    plotYes = T\n\n    # Plot type\n    if ( !is.null( type ) ) {\n\n      if ( type == 'blank' | type == 'Blank' ) {\n        plot( xl, yl, type = 'n', xlab = ' ',\n              ylab = ' ', xaxt = 'n', yaxt = 'n',\n              bty = 'n' )\n      }\n\n      plotYes = F\n\n    } else type = 'n'\n\n    if ( plotYes )\n      plot( xl, yl, type = type, xlab = xlb, ylab = ylb,\n            bty = bx, ... )\n\n  }\n\n  if ( object$type == 'PDF' ) {\n\n    # Determine x and y-axis boundaries\n    if ( is.null( inc ) ) inc = .2\n    xl = lower_upper( inc[1], object$pd$x )\n    if ( is.null( y ) ) yl = c(0,2) else yl = y\n\n    # Default options for plot\n    if ( is.null( xlab ) ) xlb = 'Time' else xlb = xlab\n    if ( is.null( ylab ) ) ylb = 'Density function'\n    else ylb = ylab\n    if ( is.null( bty ) ) bx = 'l' else bx = bty\n\n    plotYes = T\n\n    # Plot type\n    if ( !is.null( type ) ) {\n\n      if ( type == 'blank' | type == 'Blank' ) {\n        plot( xl, yl, type = 'n', xlab = ' ',\n              ylab = ' ', xaxt = 'n', yaxt = 'n',\n              bty = 'n' )\n      }\n\n      plotYes = F\n\n    } else type = 'n'\n\n    if ( plotYes )\n      plot( xl, yl, type = type, xlab = xlb, ylab = ylb,\n            bty = bx, ... )\n\n  }\n\n  if ( object$type == 'QPE' ) {\n\n    # Determine x and y-axis boundaries\n    if ( is.null( inc ) ) inc = .2\n    xl = lower_upper( inc, na.omit( object$pd$x ) )\n    if ( is.null( y ) ) yl = c(0,1) else yl = y\n\n    # Default options for plot\n    if ( is.null( xlab ) ) xlb = 'Time' else xlb = xlab\n    if ( is.null( ylab ) ) ylb = 'Quantile function'\n    else ylb = ylab\n    if ( is.null( bty ) ) bx = 'l' else bx = bty\n\n    plotYes = T\n\n    # Plot type\n    if ( !is.null( type ) ) {\n\n      if ( type == 'blank' | type == 'Blank' ) {\n        plot( xl, yl, type = 'n', xlab = ' ',\n              ylab = ' ', xaxt = 'n', yaxt = 'n',\n              bty = 'n' )\n      }\n\n      plotYes = F\n\n    } else type = 'n'\n\n    if ( plotYes )\n      plot( xl, yl, type = type, xlab = xlb, ylab = ylb,\n            bty = bx, ... )\n\n  }\n\n  if ( object$type == 'PVT' ) {\n\n    # Determine x and y-axis boundaries\n    if ( is.null( inc ) ) inc = .2\n    yl = lower_upper( inc, as.vector( na.omit( object$pd$y ) ) )\n    if ( is.null( y ) ) xl = c(0,1) else xl = y\n\n    # Default options for plot\n    if ( is.null( xlab ) ) xlb = 'Probability' else xlb = xlab\n    if ( is.null( ylab ) ) ylb = 'Time'\n    else ylb = ylab\n    if ( is.null( bty ) ) bx = 'l' else bx = bty\n\n    plotYes = T\n\n    # Plot type\n    if ( !is.null( type ) ) {\n\n      if ( type == 'blank' | type == 'Blank' ) {\n        plot( xl, yl, type = 'n', xlab = ' ',\n              ylab = ' ', xaxt = 'n', yaxt = 'n',\n              bty = 'n' )\n      }\n\n      plotYes = F\n\n    } else type = 'n'\n\n    if ( plotYes )\n      plot( xl, yl, type = type, xlab = xlb, ylab = ylb,\n            bty = bx, ... )\n\n  }\n\n}\n\n# Lookup - 06\n#' Computes Uncertainty Intervals for 'rtplots' Objects\n#'\n#' A function that computes a specified uncertainty\n#' interval (such as \\eqn{\\pm} 2 standard errors from\n#' the mean) for a 'rtplots' object.\n#'\n#' @param object a 'rtplots' object.\n#' @param f a function to compute the boundaries of\n#'   the uncertainty interval given the desired\n#'   range of coverage (takes at least two parameters,\n#'   a vector \\code{x} and a range \\code{interval}).\n#' @param alpha the desired width of coverate for the\n#'   given uncertainty interval.\n#' @param ... additional parameters for the\n#'   function \\code{f}.\n#'\n#' @return Forthcoming\n#'\n#' @export\nuncertainty = function( object, f = NULL,\n                        alpha = .95, ... ) {\n\n  # If no function is provided, assume uncertainty\n  # intervals should be calculated using the\n  # standard error of the mean\n  if ( is.null( f ) ) {\n    f = function(x,interval) {\n      s = sd( x )/sqrt( length(x) ) # Standard error\n      m = mean(x)\n      return( c( m - abs( qnorm(interval[1]) )*s,\n                 m + abs( qnorm(interval[2] ) )*s ) )\n    }\n  }\n\n  # Determine lower and upper boundaries\n  interval = numeric(2);\n  interval[1] = (1 - alpha)/2\n  interval[2] = interval[1] + alpha\n\n  # Initialize output\n  ud = NULL\n  pd = NULL\n\n  # If there is more than one group\n  if ( object$n_g > 1 ) {\n\n    l = nrow( object$pd )\n\n    ud = data.frame( x = rep( NA, l * 3 ),\n                     y = rep( NA, l * 3 ),\n                     loc = rep( NA, l * 3 ),\n                     v = rep( NA, l * 3 ),\n                     i = rep( NA, l * 3 ) )\n\n    # Loop over choice/accuracy values\n    sta = 1; end = 0\n    for ( i in 1:(object$n_v) ) {\n\n      # Compute uncertainty intervals\n      if ( !is.null( object$xm ) ) {\n        xui = apply( object$xm[[i]], 2, f, interval = interval,\n                     ... )\n      } else xui = NULL\n      if ( !is.null( object$ym ) ) {\n        yui = apply( object$ym[[i]], 2, f, interval = interval,\n                     ... )\n      } else yui = NULL\n\n      sel = object$val[ i ] == object$pd$v\n\n      # Center values\n      end = end + sum( sel )\n      ud$x[ sta:end ] = object$pd$x[ sel ]\n      ud$y[ sta:end ] = object$pd$y[ sel ]\n      ud$v[ sta:end ] = object$pd$v[ sel ]\n      ud$loc[ sta:end ] = 'center'\n      ud$i[ sta:end ] = 1:sum(sel)\n      sta = end + 1\n\n      # Lower boundary\n      end = end + sum( sel )\n      if ( is.null( xui ) )\n        ud$x[ sta:end ] = object$pd$x[ sel ] else\n          ud$x[ sta:end ] = xui[1,]\n      if ( is.null( yui ) )\n        ud$y[ sta:end ] = object$pd$y[ sel ] else\n          ud$y[ sta:end ] = yui[1,]\n      ud$v[ sta:end ] = object$pd$v[ sel ]\n      ud$loc[ sta:end ] = 'lower'\n      sta = end + 1\n\n      # Upper boundary\n      end = end + sum( sel )\n      if ( is.null( xui ) )\n        ud$x[ sta:end ] = object$pd$x[ sel ] else\n          ud$x[ sta:end ] = xui[2,]\n      if ( is.null( yui ) )\n        ud$y[ sta:end ] = object$pd$y[ sel ] else\n          ud$y[ sta:end ] = yui[2,]\n      ud$v[ sta:end ] = object$pd$v[ sel ]\n      ud$loc[ sta:end ] = 'upper'\n      sta = end + 1\n\n    }\n\n    pd = data.frame( xl = rep( NA, l * 2 ),\n                     xu = rep( NA, l * 2 ),\n                     yl = rep( NA, l * 2 ),\n                     yu = rep( NA, l * 2 ) )\n    pd$xl = c( ud$x[ ud$loc == 'lower' ],\n               ud$x[ ud$loc == 'center' ] )\n    pd$xu = c( ud$x[ ud$loc == 'upper' ],\n               ud$x[ ud$loc == 'center' ] )\n    pd$yl = c( ud$y[ ud$loc == 'center' ],\n               ud$y[ ud$loc == 'lower' ] )\n    pd$yu = c( ud$y[ ud$loc == 'center' ],\n               ud$y[ ud$loc == 'upper' ] )\n    pd$v = rep( ud$v[ ud$loc == 'center' ], 2 )\n    pd$i = rep( ud$i[ ud$loc == 'center' ], 2 )\n\n  }\n\n  out = list(\n    pd = pd,\n    ud = ud,\n    xm = object$xm,\n    ym = object$ym,\n    val = object$val\n  )\n\n  # Define new class\n  class( out ) = 'rtplots_ui';\n\n  return( out )\n}\n\n# Lookup - 07\n#' Draw Uncertainty Intervals\n#'\n#' A convenience function that draws uncertainty\n#' intervals computed from a 'rtplots' object onto\n#' an already existing plot.\n#'\n#' @param ui a 'rtplots_ui' object.\n#' @param val the choice/accuracy value for which to\n#'   draw the uncertainty intervals.\n#' @param ind the index of the desired choice/accuracy\n#'   value over which to draw uncertainty intervals.\n#' @param flip logical; if \\code{true} the y-axis\n#'   values are flipped to be negative.\n#' @param type the type of method used to draw the\n#'   uncertainty interval. Options are\n#'   \\itemize{\n#'     \\item \\code{segments}.\n#'     \\item \\code{arrows}.\n#'     \\item \\code{polygon}.\n#'   }\n#' @param ... additional plotting parameters. See\n#'   \\code{\\link[graphics]{segments}},\n#'   \\code{\\link[graphics]{arrows}}, and\n#'   \\code{\\link[graphics]{polygon}}.\n#'\n#' @export\ndraw_ui = function( ui, val = NULL, ind = 1,\n                    flip = F, type = 'segments', ... ) {\n\n  if ( !is.null( val ) ) {\n    vl = val == ui$pd$v\n  } else {\n    vl = ui$val[ ind ] == ui$pd$v\n  }\n  if (!flip) w = 1 else w = -1\n\n  segment_names = c( 'segments', 's', 'seg' )\n  if ( type %in% segment_names ) {\n    segments( ui$pd$xl[vl], w*ui$pd$yl[vl],\n              ui$pd$xu[vl], w*ui$pd$yu[vl], ... )\n  }\n\n  polygon_names = c( 'polygon', 'p', 'poly' )\n  if ( type %in% polygon_names ) {\n\n    polygon( c( ui$pd$xl[vl], rev( ui$pd$xu[vl] ) ),\n             c( ui$pd$yu[vl], rev( ui$pd$yl[vl] ) ),\n             ... )\n  }\n\n  arrow_names = c( 'arrows', 'a', 'arr' )\n  if ( type %in% arrow_names ) {\n    arrows( ui$pd$xl[vl], w*ui$pd$yl[vl],\n            ui$pd$xu[vl], w*ui$pd$yu[vl], ... )\n  }\n\n}\n\n# Lookup - 08\n#' Add Points or Lines to a RT Plot\n#'\n#' A convenience function that draws points or\n#' line segments onto an already existing plot. Useful\n#' for adding summary statistics (e.g., the mean or\n#' median).\n#'\n#' @param object a rtplots object or a list with the\n#'   x and y-axis values to plot.\n#' @param T_x the test statistic(s) to be added to the\n#'   existing figure.\n#' @param T_g the test statistic to use when collapsing\n#'   over a grouping factor.\n#' @param val Forthcoming.\n#' @param ind Forthcoming.\n#' @param type Forthcoming.\n#' @param out Forthcoming.\n#' @param ... Forthcoming.\n#'\n#' @export\nadd_to_rtplot = function( object, T_x = mean, T_g = mean, val = NULL,\n                          ind = 1, type = 'p', out = T, ... ) {\n\n  # Function to calculate values for y-axis\n  # using linear interpolation\n  f = function( x ) {\n\n    ind = max( which( xa < x ) )\n    if ( ind == -Inf ) {\n      out = ya[1];\n    } else {\n\n      if ( ind == length(xa) ) {\n        out = ya[ length(xa) ]\n      } else {\n        pts = c( ind, ind + 1 )\n        out = ln_interp( x, ya[ pts ], xa[ pts ] )\n      }\n\n    }\n\n    return( out )\n  }\n\n  if ( is.rtplots( object ) ) {\n\n    # If it isn't a probability versus time plot\n    if ( object$type != 'PVT' ) {\n\n      # If there is no grouping factor\n\n      if ( object$n_g <= 1 ) {\n\n        if ( !is.null( val ) ) {\n          vl = val == object$ad$v\n          vly = val == object$pd$v\n        } else {\n          vl = object$val[ ind ] == object$ad$v\n          vly = object$val[ ind ] == object$pd$v\n        }\n\n        ts = T_x( object$ad$t[vl] )\n\n        # Extract plotting values\n        xa = object$pd$x[vly] # x-axis\n        ya = object$pd$y[vly] # y-axis\n\n        # Determine y-axis values\n        ny = sapply( ts, f )\n\n        output = list( x = ts, y = ny )\n\n      } else {\n\n        if ( !is.null( val ) ) {\n          vl = val == object$ad$v\n          vly = val == object$pd$v\n        } else {\n          vl = object$val[ ind ] == object$ad$v\n          vly = object$val[ ind ] == object$pd$v\n        }\n\n        dmn = length( T_x( object$ad$t[vl] ) )\n        ts_all = by( object$ad$t[vl], list( object$ad$g[vl] ), T_x )\n        ts_all = matrix( unlist( ts_all ), length( ts_all ), dmn, byrow = T )\n        ts = apply( ts_all, 2, T_g )\n\n        # Extract plotting values\n        xa = object$pd$x[vly] # x-axis\n        ya = object$pd$y[vly] # y-axis\n\n        # Determine y-axis values\n        ny = sapply( ts, f )\n\n        output = list( x = ts, y = ny )\n\n      }\n    }\n  } else {\n    pass = F\n    if ( is.list( object ) ) {\n      if ( all( c('x','y') %in% names( object ) ) ) {\n        pass = T\n        output = object\n      }\n      if (!pass) stop( 'Please pass in an \"rtplots\" object',\n                       .call = FALSE )\n    }\n  }\n\n  if ( type == 's' | type == 'segments' ) {\n    segments( output$x, 0, output$x, output$y, ... )\n  }\n  if ( type == 'p' | type == 'points' ) {\n    points( output$x, output$y, ... )\n  }\n\n  if ( out ) return( output )\n}\n\n# Lookup - 09\n#' Create a Probability versus Time Figure\n#'\n#' A convenience function that draws points, lines, or\n#' line segments for a probability versus time figure\n#' onto an already existing plot. Allows fine-tune\n#' control of plotting parameters such as point type,\n#' size, etc.\n#'\n#' @param object a rtplots object.\n#'\n#'\n#' @export\npvt_plot = function( object, keep = NULL, ind = NULL, val = NULL, type = 'p',\n                     pch = NULL, cex = NULL, col = NULL,\n                     bg = NULL, lwd = NULL ) {\n\n  if ( is.rtplots( object ) ) {\n\n    if ( object$type == 'PVT' ) {\n\n      # If a choice value is given\n      if ( !is.null( val ) ) {\n        vl = val == object$pd$v\n      } else if ( !is.null( ind ) ) {\n        vl = object$val[ ind ] == object$pd$v\n      } else {\n        vl = rep( T, nrow( object$pd ) )\n      }\n\n      # Extract relevant data\n      if ( is.null( keep ) ) keep = rep( T, nrow( object$pd ) )\n\n      # Extract relevant data\n      pd = object$pd[ vl & keep, ]\n\n      # Dimensions\n      R = nrow( pd )\n      C = dim( pd$y )[2]\n\n      if ( type == 'p' | type == 'points' ) {\n\n        # Extract plotting options\n        pch = pvt_default_options( pch, pd, ver = 'pch' )\n        cex = pvt_default_options( cex, pd, ver = 'cex' )\n        col = pvt_default_options( col, pd, ver = 'col' )\n        bg = pvt_default_options( bg, pd, ver = 'bg' )\n\n        for ( r in 1:R ) {\n          x = rep( pd$x[r], C )\n          y = pd$y[r,]\n          points( x, y, pch = pch[r,], col = col[r,], cex = cex[r,], bg = bg[r,] )\n        }\n\n      }\n\n      if ( type == 'l' | type == 'lines' ) {\n\n        # Extract plotting options\n        lty = pvt_default_options( pch, pd, ver = 'lty' )\n        lwd = pvt_default_options( cex, pd, ver = 'lwd' )\n        col = pvt_default_options( col, pd, ver = 'col' )\n\n        # Loop over test statistic values\n        for ( c in 1:C ) {\n          x = pd$x\n          y = pd$y[,c]\n          ord = order( x )\n          lines( x[ord], y[ord], lty = lty[ ord, c ],\n                 lwd = lwd[ ord, c ], col = col[ ord, c ] )\n        }\n      }\n\n      if ( type == 's' | type == 'segments' ) {\n\n        # Extract plotting options\n        lty = pvt_default_options( pch, pd, ver = 'lty' )\n        lwd = pvt_default_options( cex, pd, ver = 'lwd' )\n        col = pvt_default_options( col, pd, ver = 'col' )\n\n        for ( u in unique( pd$cv ) ) {\n\n          sel = pd$cv == u\n          for ( c in 1:C ) {\n            lines( pd$x[sel], pd$y[sel,c],\n                   lty = lty[ sel, c ], lwd = lwd[ sel, c ],\n                   col = col[ sel, c ] )\n          }\n\n        }\n\n      }\n\n    } else stop( 'No values for a PvT plot', .call = FALSE )\n\n  } else {\n    stop( 'Not an rtplots object', .call = FALSE )\n  }\n\n}\n",
    "created" : 1495914176960.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3016934954",
    "id" : "FFBD1CB9",
    "lastKnownWriteTime" : 1506633090,
    "last_content_update" : 1506633088643,
    "path" : "F:/Stuff/Kevin's Stuff/Postdoc/R packages/rtplots/R/plotting_functions.R",
    "project_path" : "R/plotting_functions.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}