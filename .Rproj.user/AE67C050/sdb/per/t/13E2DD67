{
    "collab_server" : "",
    "contents" : "#-------------------#\n# Utility functions #\n#-------------------#\n\n# Index\n# Lookup - 01:  p_cat [tested]\n# Lookup - 02:  ln_interp\n# Lookup - 03:  multiple_options\n# Lookup - 04:  extract_var\n# Lookup - 05:  pow\n# Lookup - 06:  which_max_min\n# Lookup - 07:  lower_upper\n\n# Lookup - 01\np_cat = function( x, val ) {\n  # Purpose:\n  # Computes the proportion of times each value in\n  # 'val' occurs.\n  # Arguments:\n  # x   - A vector of observations\n  # val - A character vector with the possible outcomes\n  # Returns:\n  # A vector of the proportions.\n\n  # Initialize output\n  out = numeric( length( val ) )\n  names( out ) = val\n\n  # Tally frequencies for each choice\n  freq = table( x )\n  # Compute associated proportions\n  prp = freq/sum( freq )\n\n  # Extract values\n  out[ names( prp ) ] = as.numeric( prp )\n\n  return( out )\n}\n\n# Lookup - 02\nln_interp = function( x, yPts, xPts ) {\n  # Purpose:\n  # Calculates the linear interpolation for a y-axis point that\n  # lies on the line between given a pair of x-axis and y-axis\n  # points.\n  # Arguments:\n  # x    - The x-axis point that corresponds to the desired y-axis\n  #        point\n  # yPts - The pair of y-axis points that the point lies between\n  # xPts - The pair of x-axis points that the point lies between\n  # Returns:\n  # The predicted y-axis point.\n\n  # Determine\n  b = diff(yPts)/diff(xPts)\n  y = yPts[1] + b*(x-xPts[1])\n\n  return( y )\n}\n\n# Lookup - 03\nmultiple_options = function( var_options, feasible_var ) {\n  # Purpose:\n  # A function that asks users to indicate which variables\n  # out of a feasible set they would like to use.\n  # Arguments:\n  # var_options  - The set of variable names\n  # feasible_var - A logical vector indicating which\n  #                variables are feasible\n  # Returns:\n  # The variable chosen by the user.\n\n  cat( 'Multiple feasible variables found.', '\\n' )\n  cat( 'Select variable:', '\\n' )\n\n  for ( i in 1:sum( feasible_var ) ) {\n    string = paste( i, ') ',\n                    var_options[ feasible_var ][i],\n                    sep = '' )\n    cat( string, '\\n' )\n  }\n\n  input = NULL\n\n  while( !is.numeric( input ) ) {\n\n    input = readline( 'Enter number: ' )\n    input = as.numeric( input )\n    if ( is.numeric( input ) ) {\n      if ( input < 1 | input > i ) input = NULL\n    }\n\n  }\n\n  return( var_options[ feasible_var ][input] )\n}\n\n# Lookup - 04\nextract_var = function( df, label, keep, type ) {\n  # Purpose:\n  # Extracts response times, choice/accuracy,\n  # and grouping variables from a data frame.\n  # Arguments:\n  # df    - A data frame\n  # label - A character vector with up to\n  #         3 labels\n  # keep  - A logical vector of matching length\n  #         to the number of observations in\n  #         df\n  # type  - The type of function (e.g., CDF,\n  #         PDF, etc.)\n  # Returns:\n  # A list, consisting of...\n  # t       = A vector of response times\n  # v       = A vector of choice values\n  # g       = A vector of indices for the grouping\n  #           factor\n  # val     = The set of possible choices\n  # n_v     = The total number of possible choices\n  # g_v     = The set of unique group indices\n  # n_g     = The total number of elements for the\n  #           grouping factor\n  # cv_v    = The levels for an optional additional\n  #           covariate\n  # n_cv    = The number of levels for the additional\n  #           covariate\n  # N       = The total number of observations\n  # ad      = A dataframe with the response times,\n  #           choice values, and current grouping\n  #           levels\n\n  vnames = names( df ) # Extract variable names\n\n  # Define defaults for covariate variable\n  cv = NULL\n  cv_v = NULL\n  n_cv = NULL\n\n  # If no labels for RT and choice variables are\n  # provided, attempt to locate variables via\n  # common variable names\n  if ( is.null( label ) ) {\n\n    ### Extract RT ###\n\n    # Define set of common variable names for RT\n    common_rt_names = c( 'RT', 'rt', 'Time', 'time',\n                         't' )\n\n    # Attempt to find default variable for RT\n    rt_label_sel = common_rt_names %in% vnames\n    if ( sum( rt_label_sel ) == 1 ) {\n      var_name = common_rt_names[ rt_label_sel ]\n      t = df[ , var_name ]\n    }\n\n    # If multiple labels\n    if ( sum( rt_label_sel ) > 1 ) {\n      # Ask user to identify variable to use\n      var_name = multiple_options( common_rt_names, rt_label_sel )\n      t = df[ , var_name ]\n    }\n\n    # If no labels\n    if ( sum( rt_label_sel ) == 0 ) {\n      stop( 'No feasible default variable names for RT found',\n            call. = FALSE )\n    }\n\n    ### Extract choice/accuracy ###\n\n    # Define set of common variable names for choice\n    common_ch_names = c( 'Choice', 'Ch', 'ch', 'choice',\n                         'Accuracy', 'accuracy', 'ac', 'Ac',\n                         'Correct', 'correct', 'Co', 'Answer',\n                         'answer' )\n\n    # Attempt to find default variable for choice\n    ch_label_sel = common_ch_names %in% vnames\n    if ( sum( ch_label_sel ) == 1 ) {\n      var_name = common_ch_names[ ch_label_sel ]\n      v = df[ , var_name ]\n    }\n\n    # If multiple labels\n    if ( sum( ch_label_sel ) > 1 ) {\n      # Ask user to identify variable to use\n      var_name = multiple_options( common_ch_names, ch_label_sel )\n      v = df[ , var_name ]\n    }\n\n    # If no labels\n    if ( sum( ch_label_sel ) == 0 ) {\n      v = rep( 1, length( t ) )\n    }\n\n    g = rep( 1, length( t ) )\n  }\n\n  # If a single label for RTs is provided\n  if ( length( label ) == 1 ) {\n\n    # If label is present\n    if ( label %in% names( df ) ) {\n      t = df[ , label ]\n      v = rep( 1, length( label ) )\n      g = rep( 1, length( t ) )\n    } else {\n      stop( 'Variable name not found in data frame',\n            call. = FALSE )\n    }\n\n  }\n\n  # If labels for RT and choice/accuracy are provided\n  if ( length( label ) == 2 ) {\n\n    if ( all( label %in% names( df ) ) ) {\n      t = df[ , label[1] ]\n      v = df[ , label[2] ]\n      g = rep( 1, length( t ) )\n    } else {\n      stop( 'Variable name(s) not found in data frame',\n            call. = FALSE )\n    }\n\n  }\n\n  if ( length( label ) >= 3 & !check_for_pvt_type(type) ) {\n\n    if ( length( label ) > 3 ) {\n      warn = paste(\n        'More than 3 variable names were provided.', '\\n',\n        'Only the first 3 will be used.' )\n      warning( warn, call. = FALSE )\n      label = label[1:3]\n    }\n\n    if ( all( label %in% names( df ) ) ) {\n      t = df[ , label[1] ]\n      v = df[ , label[2] ]\n      g = df[ , label[3] ]\n    } else {\n      stop( 'Variable name(s) not found in data frame',\n            call. = FALSE )\n    }\n\n  }\n\n  is_pvt = check_for_pvt_type(type)\n  if ( is_pvt & length( label ) < 4 )\n    stop( 'Need a grouping factor and an additional covariate for PvT figures',\n          call. = FALSE )\n\n  if ( length( label ) >= 4 & is_pvt ) {\n\n    if ( length( label ) > 4 ) {\n      warn = paste(\n        'More than 4 variable names were provided.', '\\n',\n        'Only the first 4 will be used.' )\n      warning( warn, call. = FALSE )\n      label = label[1:4]\n    }\n\n    if ( all( label %in% names( df ) ) ) {\n      t = df[ , label[1] ]\n      v = df[ , label[2] ]\n      g = df[ , label[3] ]\n      cv = df[ , label[4] ]\n    } else {\n      stop( 'Variable name(s) not found in data frame',\n            call. = FALSE )\n    }\n\n  }\n\n  if ( is.null( keep ) ) {\n    keep = rep( T, length( t ) )\n  }\n\n  val = unique( v );\n  n_v = length( val )\n  cur_g = g[ keep ]\n  if ( all( is.na( cur_g ) ) )\n    cur_g[ is.na( cur_g ) ] = 1\n  ad = data.frame( t = t[ keep ],\n                   v = v[ keep ],\n                   g = cur_g )\n  g_v = unique( cur_g )\n  n_g = length( g_v )\n  if ( !is.null( cv ) ) {\n    ad$cv = cv[keep]\n    cv_v = unique(cv[keep])\n    n_cv = length( cv_v )\n  }\n\n  output = list(\n    ad = ad,\n    val = val,\n    n_v = n_v,\n    g_v = g_v,\n    n_g = n_g,\n    cv_v = cv_v,\n    n_cv = n_cv,\n    N = nrow( ad ) )\n\n  return( output )\n}\n\n# Lookup - 05\npow = function( x, a ) {\n  # Purpose:\n  # A function to raise a variable to a power.\n  # Arguments:\n  # x - A continuous value\n  # a - The power to raise the value\n  # Returns:\n  # The result of the value raised to the desired power.\n\n  return( x^a )\n}\n\n# Lookup - 06\nwhich_max_min = function( x, max = T ) {\n  # Purpose:\n  # A function that extracts the index for the\n  # largest or smallest value in a vector.\n  # Arguments:\n  # x   - A vector of values\n  # max - Logical; if true, the largest value is\n  #       extracted\n  # Returns:\n  # The position of the largest/smallest value in\n  # the vector.\n\n  if ( max ) {\n    out = which( x == max( x ) )\n  } else {\n    out = which( x == min( x ) )\n  }\n\n  return( out )\n}\n\n# Lookup - 07\nlower_upper = function( int, dat ) {\n  # Purpose:\n  # Computes the lower and upper bounds for a set\n  # of data within a desired increment.\n  # Arguments:\n  # int - The increment to round down/up to for\n  #       the limits\n  # dat - A vector of data\n  # Returns:\n  # A vector with a lower and upper limit.\n\n  ll = int*floor(min(dat)/int)\n  ll = c(ll,int*ceiling(max(dat)/int))\n\n  return( ll )\n}\n",
    "created" : 1506021370995.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2776061104",
    "id" : "13E2DD67",
    "lastKnownWriteTime" : 1506622748,
    "last_content_update" : 1506622746387,
    "path" : "F:/Stuff/Kevin's Stuff/Postdoc/R packages/rtplots/R/utility.R",
    "project_path" : "R/utility.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}