{
    "contents" : "# Load in data\nd = priming_data\n# Select 2AFC task only\nsel = d$Condition < 8\nd = d[sel,]\n# Collapse over type of correct response (left/right)\nd$Cnd = 1;\ninc = 2\nfor (i in c(2,4,6) ) {\n  d$Cnd[ d$Condition == i | d$Condition == i+1 ] = inc;\n  inc = inc + 1;\n}\n\nx11()\n\nblankRTplot(ver='PvT',tDim=c(.2,1.2))\nrt = d$RT; ch = d$Accuracy; grp = d$Subject\ncvrts = d$Cnd\nplt = list( pch = 19, col = 1:4 )\noutput = pvt_points( rt, ch, cvrts, grp = grp, T_x = T_x, plt = plt,\n            opt = list( out = T ) )\n\nadd_uncertainty2 = function( output, f = NULL, alpha = .95,\n                            opt = list( ), ... ) {\n  \n  # Set options for drawing and output\n  if ( length( opt$draw ) == 0 ) draw = T else draw = opt$draw\n  if ( length( opt$out ) == 0 ) out = F else out = opt$out\n  # Save options\n  optOut = list( draw = draw, out = out )\n  \n  # Extract choice to condition on\n  sel = output$v$sel\n  # Extract input\n  rt = output$i$rt; ch = output$i$ch\n  # Extract options on whether to flip\n  flip = output$opt$flip\n  \n  # Determine if there is a grouping variable\n  grp = output$i$grp\n  \n  # If no function is provided, define a uncertainty interval\n  # based on the mean and t-distribution\n  if ( length( f ) == 0 ) {\n    \n    f = function(x,alpha) {\n      n = length(x)\n      se = sd(x)/sqrt( n )\n      crt = abs( qt( (1-alpha)/2, n - 1, lower.tail = T ) )\n      ui = c( mean(x) - crt*se, mean(x) + crt*se )\n      ui[ ui < 0 ] = 0\n      \n      return(ui)\n    }\n    \n  }\n  \n  if ( length( grp ) == 0 ) stop('Need grouping factor')\n  \n  # For 'pvt_point' functions\n  if ( is.data.frame( output$g$w ) ) {\n    \n    yvAll = output$g$w\n    xvAll = output$g$x\n    \n    yv = aggregate(yvAll$T_x,list(yvAll$Cv),f,alpha=.95)\n    xv = aggregate(xvAll$P,list(xvAll$Cv),f,alpha=.95)\n    dmn = dim( yv )\n    if (draw) {\n      \n      for ( i in 2:dmn[2] ) {\n        for ( j in 1:dmn[1] ) {\n          \n          addEllipse( diff( xv[[2]][j,] ),\n                      diff( yv[[i]][j,] ),\n                      output$pv$x[j],\n                      output$pv$y[j,i-1], ... )\n        }\n      }\n      \n    }\n    \n    # Save output\n    newOutput = list(\n      pv = cbind( x = xv$x, y = yv[,2:dmn[2]] ),\n      ui = list( x = xv, y = yv ),\n      opt = opt )\n    \n    if (out) return( newOutput ) else return()\n  }\n  \n  # For curve functions\n  if ( !is.matrix( output$g$x ) ) {\n    \n    # Calculate uncertainty interval for y-axis values\n    ui = apply( output$g$w, 2, f, alpha = alpha )\n    x = output$g$x\n    \n    # Plot uncertainty interval\n    xa = c( x, rev(x) )\n    ya = c( ui[1,], rev( ui[2,] ) )\n    if (flip) ya = -ya\n    \n    if (draw) {\n      \n      polygon( xa, ya, ... )\n      \n    }\n    \n    # Save output\n    newOutput = list(\n      pv = cbind( x = xa, y = ya ),\n      ui = list( y = ui ),\n      opt = opt )\n    \n  }\n  \n  # For point functions\n  if ( is.matrix( output$g$x ) ) {\n    \n    # Extract centering info\n    xc = output$pv[,'x']\n    yc = output$pv[,'y']\n    # Compute uncertainty variables for both x and y-axis\n    ya = apply( output$g$w, 2, f, alpha = alpha )\n    xa = apply( output$g$x, 2, f, alpha = alpha )\n    \n    # Plot intervals\n    if ( draw ) {\n      segments( xa[1,], yc, xa[2,], yc, ... )\n      segments( xc, ya[1,], xc, ya[2,], ... )\n    }\n    \n    # Save output\n    newOutput = list(\n      pv = cbind( x1 = xa[1,], x2 = xa[2,],\n                  y1 = ya[1,], y2 = ya[2,],\n                  xc = xc, yc = yc ),\n      ui = list( x = xa, y = ya ),\n      opt = opt )\n    \n  }\n  \n  if (out ) return( newOutput )\n}\n\nadd_uncertainty2( output, col = rgb(.5,.5,.5,.2), border = NA )",
    "created" : 1478614752168.000,
    "dirty" : true,
    "encoding" : "",
    "folds" : "",
    "hash" : "2807664257",
    "id" : "75AE4187",
    "lastKnownWriteTime" : 7011605692497750387,
    "path" : null,
    "project_path" : null,
    "properties" : {
        "tempName" : "Untitled2"
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "type" : "r_source"
}